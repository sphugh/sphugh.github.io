<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="武汉大学12级，就职于南京测勘院交通工程事业部。擅长各项大地测量，编程，深入研究gamit，PCL，slam，TensorFlow，pytorch。此为博客一枚。"><title>Hello World | 胡少</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Hello World</h1><a id="logo" href="/.">胡少</a><p class="description">格物致知</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Hello World</h1><div class="post-meta">2021-01-25</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Table-of-Contents"><span class="toc-number">1.</span> <span class="toc-text">Table of Contents</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Introduction"><span class="toc-number">2.</span> <span class="toc-text">Introduction:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Build-instructions"><span class="toc-number">3.</span> <span class="toc-text">Build instructions:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Thread-pool"><span class="toc-number">4.</span> <span class="toc-text">Thread pool</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Queue"><span class="toc-number">4.1.</span> <span class="toc-text">Queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Submit-function"><span class="toc-number">4.2.</span> <span class="toc-text">Submit function</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Submit-implementation"><span class="toc-number">4.2.1.</span> <span class="toc-text">Submit implementation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Variadic-template-function"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">Variadic template function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Function-declaration"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">Function declaration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Function-body"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">Function body</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread-worker"><span class="toc-number">4.3.</span> <span class="toc-text">Thread worker</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Usage-example"><span class="toc-number">5.</span> <span class="toc-text">Usage example</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Use-Case-1"><span class="toc-number">5.1.</span> <span class="toc-text">Use-Case #1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Use-Case-2"><span class="toc-number">5.2.</span> <span class="toc-text">Use-Case #2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Use-Case-3"><span class="toc-number">5.3.</span> <span class="toc-text">Use-Case #3</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Future-work"><span class="toc-number">6.</span> <span class="toc-text">Future work</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#References"><span class="toc-number">7.</span> <span class="toc-text">References</span></a></li></ol></div></div><div class="post-content"><p>threadpool介绍</p>
<span id="more"></span>
<h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><p>&nbsp;<a target="_blank" rel="noopener" href="https://github.com/mtrebi/thread-pool/blob/master/README.md#introduction">Introduction</a>  <br/><br>&nbsp;<a target="_blank" rel="noopener" href="https://github.com/mtrebi/thread-pool/blob/master/README.md#build-instructions">Build instructions</a>  <br/><br>&nbsp;<a target="_blank" rel="noopener" href="https://github.com/mtrebi/thread-pool/blob/master/README.md#thread-pool">Thread pool</a><br/><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a target="_blank" rel="noopener" href="https://github.com/mtrebi/thread-pool/blob/master/README.md#queue">Queue</a><br/><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a target="_blank" rel="noopener" href="https://github.com/mtrebi/thread-pool/blob/master/README.md#submit-function">Submit function</a>  <br/><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a target="_blank" rel="noopener" href="https://github.com/mtrebi/thread-pool/blob/master/README.md#thread-worker">Thread worker</a>  <br/><br>&nbsp;<a target="_blank" rel="noopener" href="https://github.com/mtrebi/thread-pool/blob/master/README.md#usage-example">Usage example</a>  <br/><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a target="_blank" rel="noopener" href="https://github.com/mtrebi/thread-pool#use-case-1">Use case#1</a>  <br/><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a target="_blank" rel="noopener" href="https://github.com/mtrebi/thread-pool#use-case-2">Use case#2</a>  <br/><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a target="_blank" rel="noopener" href="https://github.com/mtrebi/thread-pool#use-case-3">Use case#3</a>  <br/><br>&nbsp;<a target="_blank" rel="noopener" href="https://github.com/mtrebi/thread-pool/blob/master/README.md#future-work">Future work</a>  <br/><br>&nbsp;<a target="_blank" rel="noopener" href="https://github.com/mtrebi/thread-pool/blob/master/README.md#references">References</a>  <br/> </p>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction:"></a>Introduction:</h1><p>A <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Thread_pool">thread pool</a> is a technique that allows developers to exploit the concurrency of modern processors in an <strong>easy</strong> and <strong>efficient</strong> manner. It’s easy because you send “work” to the pool and somehow this work gets done without blocking the main thread. It’s efficient because threads are not initialized each time we want the work to be done. Threads are initialized once and remain inactive until some work has to be done. This way we minimize the overhead.</p>
<p>There are many more Thread pool implementations in C++, many of them are probably better (safer, faster…) than mine. However,I believe my implementation are <strong>very straightforward and easy to understand</strong>. </p>
<p><strong>Disclaimer: Please Do not use this project in a professional environment. It may contain bugs and/or not work as expected.</strong> I did this project to learn how C++11 Threads work and provide an easy way for other people to understand it too. </p>
<h1 id="Build-instructions"><a href="#Build-instructions" class="headerlink" title="Build instructions:"></a>Build instructions:</h1><p>This project has been developed using Netbeans and Linux but it should work on Windows, MAC OS and Linux. It can be easily build using CMake and different other generators. The following code can be used to generate the VS 2017 project files:</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// VS 2017</span>
cd <span class="token operator">&lt;</span>project<span class="token operator">-</span>folder<span class="token operator">></span>
mkdir build
cd build<span class="token operator">/</span>
cmake <span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token string">"Visual Studio 15 2017 Win64"</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Then, from VS you can edit and execute the project. Make sure that <strong>main project is set up as the startup project</strong></p>
<p>If you are using Linux, you need to change the generator (use the default) and execute an extra operation to actually make it executable:</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Linux</span>
cd <span class="token operator">&lt;</span>project<span class="token operator">-</span>folder<span class="token operator">></span>
mkdir build
cd build<span class="token operator">/</span>
cmake <span class="token punctuation">.</span><span class="token punctuation">.</span>
make
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="Thread-pool"><a href="#Thread-pool" class="headerlink" title="Thread pool"></a>Thread pool</h1><p>The way that I understand things better is with images. So, let’s take a look at the image of thread pool given by Wikipedia:</p>
<p align="center">  <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/0c/Thread_pool.svg/580px-Thread_pool.svg.png"> </p>

<p>As you can see, we have three important elements here:</p>
<ul>
<li><em>Tasks Queue</em>. This is where the work that has to be done is stored.</li>
<li><em>Thread Pool</em>. This is set of threads (or workers) that continuously take work from the queue and do it.</li>
<li><em>Completed Tasks</em>. When the Thread has finished the work we return “something” to notify that the work has finished.</li>
</ul>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>We use a queue to store the work because it’s the more sensible data structure. We want the work to be <strong>started</strong> in the same order that we sent it. However, this queue is a little bit <strong>special</strong>. As I said in the previous section, threads are continuously (well, not really, but let’s assume that they are) querying the queue to ask for work. When there’s work available, threads take the work from the queue and do it. What would happen if two threads try to take the same work at the same time? Well, the program would crash.</p>
<p>To avoid these kinds of problems, I implemented a wrapper over the standard C++ Queue that uses mutex to restrict the concurrent access. Let’s see a small sample of the SafeQueue class:</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_lock<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    m_queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>To enqueue the first thing we do is lock the mutex to make sure that no one else is accessing the resource. Then, we push the element to the queue. When the lock goes out of scopes it gets automatically released. Easy, huh? This way, we make the Queue thread-safe and thus we don’t have to worry many threads accessing and/or modifying it at the same “time”.</p>
<h2 id="Submit-function"><a href="#Submit-function" class="headerlink" title="Submit function"></a>Submit function</h2><p>The most important method of the thread pool is the one responsible of adding work to the queue. I called this method <strong>submit</strong>. It’s not difficult to understand how it works but its implementation can seem scary at first. Let’s think about <strong>what</strong> should do and after that we will worry about <strong>how</strong> to do it. What:</p>
<ul>
<li>Accept any function with any parameters.</li>
<li>Return “something” immediately to avoid blocking main thread. This returned object should <strong>eventually</strong> contain the result of the operation.</li>
</ul>
<p>Cool, let’s see <strong>how</strong> we can implement it.</p>
<h3 id="Submit-implementation"><a href="#Submit-implementation" class="headerlink" title="Submit implementation"></a>Submit implementation</h3><p>The complete submit functions looks like this:</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Submit a function to be executed asynchronously by the pool</span>
template<span class="token operator">&lt;</span>typename F<span class="token punctuation">,</span> typename<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">></span>
<span class="token keyword">auto</span> <span class="token function">submit</span><span class="token punctuation">(</span>F<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token operator">-></span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>future<span class="token operator">&lt;</span><span class="token function">decltype</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// Create a function with bounded parameters ready to execute</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>function<span class="token operator">&lt;</span><span class="token function">decltype</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> func <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>forward<span class="token operator">&lt;</span>F<span class="token operator">></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>forward<span class="token operator">&lt;</span>Args<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// Encapsulate it into a shared ptr in order to be able to copy construct / assign </span>
    <span class="token keyword">auto</span> task_ptr <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>make_shared<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>packaged_task<span class="token operator">&lt;</span><span class="token function">decltype</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// Wrap packaged task into void function</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> wrapper_func <span class="token operator">=</span> <span class="token punctuation">[</span>task_ptr<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      <span class="token punctuation">(</span><span class="token operator">*</span>task_ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// Enqueue generic wrapper function</span>
    m_queue<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>wrapperfunc<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// Wake up one thread if its waiting</span>
    m_conditional_lock<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// Return future from promise</span>
    <span class="token keyword">return</span> task_ptr<span class="token operator">-></span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Nevertheless, we’re going to inspect line by line what’s going on in order to fully understand how it works. </p>
<h4 id="Variadic-template-function"><a href="#Variadic-template-function" class="headerlink" title="Variadic template function"></a>Variadic template function</h4><pre class="line-numbers language-c"><code class="language-c">template<span class="token operator">&lt;</span>typename F<span class="token punctuation">,</span> typename<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>This means that the next statement is templated. The first template parameter is called F (our function) and second one is a parameter pack. A parameter pack is a special template parameter that can accept zero or more template arguments. It is, in fact, a way to express a variable number of arguments in a template. A template with at least one parameter pack is called <strong>variadic template</strong></p>
<p>Summarizing, we are telling the compiler that our submit function is going to take one generic parameter of type F (our function) and a parameter pack Args (the parameters of the function F).</p>
<h4 id="Function-declaration"><a href="#Function-declaration" class="headerlink" title="Function declaration"></a>Function declaration</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">auto</span> <span class="token function">submit</span><span class="token punctuation">(</span>F<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token operator">-></span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>future<span class="token operator">&lt;</span><span class="token function">decltype</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>This may seem weird but, it’s not. A function, in fact, can be declared using two different syntaxes. The following is the most well known:</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">return</span><span class="token operator">-</span>type <span class="token function">identifier</span> <span class="token punctuation">(</span> argument<span class="token operator">-</span>declarations<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>But, we can also declare the function like this:</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">auto</span> <span class="token function">identifier</span> <span class="token punctuation">(</span> argument<span class="token operator">-</span>declarations<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token operator">-></span> return_type
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Why two syntaxes? Well, imagine that you have a function that has a return type that depends on the input parameters of the function. Using the first syntax you can’t declare that function without getting a compiler error since you  would be using a variable in the return type that has not been declared yet (because the return type declaration goes before the parameters type declaration). </p>
<p>Using the second syntax you can declare the function to have return type <strong>auto</strong> then, using the -&gt; you can declare the return type depending on the arguments of the functions that have been declared previously. </p>
<p>Now, let’s inspect the parameters of the submit function. When the type of a parameter is declared as <strong>T&amp;&amp;</strong> for some deducted type T that parameter is a <strong>universal reference</strong>. This term was coined by <a target="_blank" rel="noopener" href="https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">Scott Meyers</a> because <strong>T&amp;&amp;</strong> can also mean r-value reference. However, in the context of type deduction, it means that it can be bound to both l-values and r-values, unlike l-value references that can only be bound to non-const objects (they bind only to modifiable lvalues) and r-value references (they bind only to rvalues).</p>
<p>The return type of the function is of type <strong>std::future<T></strong>. An std::future is a special type that provides a mechanism to access the result of asynchronous operations, in our case, the result of executing a specific function. This makes sense with what we said earlier.</p>
<p>Finally, the template type of std::future is <strong>decltype(f(args…))</strong>. Decltype is a special C++ keyword that inspects the declared type of an entity or the type and value category of an expression. In our case, we want to know the return type of the function <em>f</em>, so we give decltype our generic function <em>f</em> and the parameter pack <em>args</em>.</p>
<h4 id="Function-body"><a href="#Function-body" class="headerlink" title="Function body"></a>Function body</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Create a function with bounded parameters ready to execute</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>function<span class="token operator">&lt;</span><span class="token function">decltype</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> func <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>forward<span class="token operator">&lt;</span>F<span class="token operator">></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>forward<span class="token operator">&lt;</span>Args<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>There are many many things happening here. First of all, the <strong>std::bind(F, Args)</strong> is a function that creates a wrapper for F with the given Args. Caling this wrapper is the same as calling F with the Args that it has been bound. Here, we are simply calling bind with our generic function <em>f</em> and the parameter pack <em>args</em> but using another wrapper <strong>std::forward<T>(t)</strong> for each parameter. This second wrapper is needed to achieve perfect forwarding of universal references.<br>The result of this bind call is a <strong>std::function<T></strong>. The std::function<T> is a C++ object that encapsulates a function. It allows you to execute the function as if it were a normal function calling the operator() with the required parameters BUT, because it is an object, you can store it, copy it and move it around. The template type of any std::function is the signature of that function: std::function&lt; return-type (arguments)&gt;. In this case, we already know how to get the return type of this function using decltype. But, what about the arguments? Well, because we bound all arguments <em>args</em> to the function <em>f</em> we just have to add an empty pair of parenthesis that represents an empty list of arguments: <strong>decltype(f(args…))()</strong>.</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Encapsulate it into a shared ptr in order to be able to copy construct / assign </span>
<span class="token keyword">auto</span> task_ptr <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>make_shared<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>packaged_task<span class="token operator">&lt;</span><span class="token function">decltype</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>The next thing we do is we create a <strong>std::packaged_task<T>(t)</strong>.  A packaged_task is a wrapper around a function that can be executed asynchronously. It’s result is stored in a shared state inside an std::future<T> object. The templated type T of an std::packaged_task<T>(t) is the type of the function <em>t</em> that is wrapping. Because we said it before, the signature of the function <em>f</em> is <strong>decltype(f(args…))()</strong> that is the same type of the packaged_task. Then, we just wrap again this packaged task inside a <strong>std::shared_ptr</strong> using the initialize function <strong>std::make_shared</strong>.</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Wrap packaged task into void function</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> wrapperfunc <span class="token operator">=</span> <span class="token punctuation">[</span>task_ptr<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  <span class="token punctuation">(</span><span class="token operator">*</span>task_ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>Again, we create a std:.function, but, note that this time its template type is <strong>void()</strong>. Independently of the function <em>f</em> and its parameters <em>args</em> this <em>wrapperfunc</em> the return type will always be <strong>void</strong>. Since all functions <em>f</em> may have different return types, the only way to store them in a container (our Queue) is wrapping them with a generic void function. Here, we are just declaring this <em>wrapperfunc</em> to execute the actual task <em>taskptr</em> that will execute the bound function <em>func</em>.</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Enqueue generic wrapper function</span>
m_queue<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>wrapperfunc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>We enqueue this <em>wrapperfunc</em>. </p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Wake up one thread if its waiting</span>
m_conditional_lock<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>Before finishing, we wake up one thread in case it is waiting.</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Return future from promise</span>
<span class="token keyword">return</span> task_ptr<span class="token operator">-></span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>And finally, we return the future of the packaged_task. Because we are returning the future that is bound to the packaged_task <em>taskptr</em> that, at the same time, is bound with the function <em>func</em>, executing this <em>taskptr</em> will automatically update the future. Because we wrapped the execution of the <em>taskptr</em> with a generic wrapper function, is the execution of <em>wrapperfunc</em> that, in fact, updates the future. Aaaaand. since we enqueued this wrapper function, it will be executed by a thread after being dequeued calling the operator().</p>
<h2 id="Thread-worker"><a href="#Thread-worker" class="headerlink" title="Thread worker"></a>Thread worker</h2><p>Now that we understand how the submit method works, we’re going to focus on how the work gets done. Probably, the simplest implementation of a thread worker could be using polling:</p>
<pre><code> Loop
    If Queue is not empty
        Dequeue work
        Do it
</code></pre>
<p>This looks alright but it’s <strong>not very efficient</strong>. Do you see why? What would happen if there is no work in the Queue? The threads would keep looping and asking all the time: Is the queue empty? </p>
<p>The more sensible implementation is done by “sleeping” the threads until some work is added to the queue. As we saw before, as soon as we enqueue work, a signal <strong>notify_one()</strong> is sent. This allows us to implement a more efficient algorithm:</p>
<pre><code>Loop
    If Queue is empty
        Wait signal
    Dequeue work
    Do it
</code></pre>
<p>This signal system is implemented in C++ with <strong>conditional variables</strong>. Conditional variables are always bound to a mutex, so I added a mutex to the thread pool class just to manage this. The final code of a worker looks like this: </p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> func<span class="token punctuation">;</span>
    bool dequeued<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>m_pool<span class="token operator">-></span>m_shutdown<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_lock<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>m_pool<span class="token operator">-></span>m_conditional_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>m_pool<span class="token operator">-></span>m_queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            m_pool<span class="token operator">-></span>m_conditional_lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        dequeued <span class="token operator">=</span> m_pool<span class="token operator">-></span>m_queue<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>dequeued<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
              <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>The code is really easy to understand so I am not going to explain anything. The only thing to note here is that, <em>func</em> is our wrapper function declared as:</p>
<pre class="line-numbers language-c"><code class="language-c">std<span class="token punctuation">:</span><span class="token punctuation">:</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> wrapperfunc <span class="token operator">=</span> <span class="token punctuation">[</span>task_ptr<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  <span class="token punctuation">(</span><span class="token operator">*</span>task_ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>So, executing this function will automatically update the future.</p>
<h1 id="Usage-example"><a href="#Usage-example" class="headerlink" title="Usage example"></a>Usage example</h1><p>Creating the thread pool is as easy as:</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Create pool with 3 threads</span>
ThreadPool <span class="token function">pool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// Initialize pool</span>
pool<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>When we want to shutdown the pool just call:</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Shutdown the pool, releasing all threads</span>
pool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>Ff we want to send some work to the pool, after we have initialized it, we just have to call the submit function:</p>
<pre class="line-numbers language-c"><code class="language-c">pool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>work<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Depending on the type of work, I’ve distinguished different use-cases. Suppose that the work that we have to do is multiply two numbers. We can do it in many different ways. I’ve implemented the three most common ways to do it that I can imagine:</p>
<ul>
<li>Use-Case #1. Function returns the result</li>
<li>Use-Case #2. Function updates by ref parameter with the result</li>
<li>Use-Case #3. Function prints the result</li>
</ul>
<p><em>Note: This is just to show how the submit function works. Options are not exclusive</em></p>
<h2 id="Use-Case-1"><a href="#Use-Case-1" class="headerlink" title="Use-Case #1"></a>Use-Case #1</h2><p>The multiply function with a return looks like this:</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Simple function that adds multiplies two numbers and returns the result</span>
<span class="token keyword">int</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> res <span class="token operator">=</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Then, the submit:</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// The type of future is given by the return type of the function</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> future <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>multiply<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>We can also use the <strong>auto</strong> keyword for convenience:</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">auto</span> future <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>multiply<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Nice, when the work is finished by the thread pool we know that the future will get updated and we can retrieve the result calling:</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> result <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> result <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>The get() function of std::future<T> always return the type T of the future. <strong>This type will always be equal to the return type of the function passed to the submit method</strong>. In this case, int.</p>
<h2 id="Use-Case-2"><a href="#Use-Case-2" class="headerlink" title="Use-Case #2"></a>Use-Case #2</h2><p>The multiply function has a parameter passed by ref:</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Simple function that adds multiplies two numbers and updates the out_res variable passed by ref</span>
<span class="token keyword">void</span>  <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> out_res<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    out_res <span class="token operator">=</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>Now, we have to call the submit function with a subtle difference. Because we are using templates and type deduction (universal references), the parameter passed by ref needs to be called using <strong>std::ref(param)</strong> to make sure that we are passing it by ref and not by value.</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> future <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>multiply<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">ref</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// result is 0</span>
future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// result is 6</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> result <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>In this case, what’s the type of future? Well, as I said before, the return type will always be equal to the return type of the function passed to the submit method. Because this function is of type void, the future  is <strong>std::future<void></strong>. Calling future.get() returns void. That’s not very useful, but we still need to call .get() to make sure that the work has been done.</p>
<h2 id="Use-Case-3"><a href="#Use-Case-3" class="headerlink" title="Use-Case #3"></a>Use-Case #3</h2><p>The last case is the easiest one. Our multiply function simply prints the result:</p>
<p>We have a simple function without output parameters. For this example I implemented the following multiplication function:</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Simple function that adds multiplies two numbers and prints the result</span>
<span class="token keyword">void</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> result <span class="token operator">=</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>
  std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> result <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Then, we can simply call:</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">auto</span> future <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>multiply<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>In this case, we know that as soon as the multiplication is done it will be printed. If we care when this is done, we can wait for it calling future.get().</p>
<p>Checkout the <a target="_blank" rel="noopener" href="https://github.com/mtrebi/thread-pool/blob/master/src/main.cpp">main</a> program for a complete example.</p>
<h1 id="Future-work"><a href="#Future-work" class="headerlink" title="Future work"></a>Future work</h1><ul>
<li>Make it more reliable and safer (exceptions)</li>
<li>Find a better way to use it with member functions (thanks to @rajenk)</li>
<li>Run benchmarks and improve performance if needed</li>
<li>Evaluate performance and impact of std::function in the heap and try alternatives if necessary. (thanks to @JensMunkHansen) </li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a target="_blank" rel="noopener" href="http://www.bogotobogo.com/cplusplus/multithreaded.php">MULTI-THREADED PROGRAMMING TERMINOLOGY - 2017</a>: Fast analysis of how a multi-thread system works</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">Universal References in C++11—Scott Meyers</a>: Universal references in C++11 by Scott Meyers</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c/">Perfect forwarding and universal references in C++</a>: Article about how and when to use perfect forwarding and universal references</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.cplusplus.com/reference/">C++ documentation</a>: Thread, conditional variables, mutex and many others…</p>
</li>
</ul>
</div><div class="tags"><a href="/tags/article/"><i class="fa fa-tag"></i>article</a></div><div class="post-nav"><a class="pre" href="/2021/04/15/Nginx%E4%B8%AD%E7%9A%84%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8/">Nginx源码概览</a><a class="next" href="/2020/04/25/C++2.0%E6%96%B0%E7%89%B9%E6%80%A7_%E8%AF%AD%E8%A8%80%E7%AF%87_1/">C++2.0新特性_语言篇_1</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/C/" style="font-size: 15px;">C</a> <a href="/tags/article/" style="font-size: 15px;">article</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/introduce/" style="font-size: 15px;">introduce</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/05/20/%E5%B9%B3%E9%A1%BA%E6%80%A7%E7%BC%96%E7%A8%8B%E5%85%AC%E5%BC%8F/">轨道平顺性概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/15/Nginx%E4%B8%AD%E7%9A%84%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8/">Nginx源码概览</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/25/threadpool/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/25/C++2.0%E6%96%B0%E7%89%B9%E6%80%A7_%E8%AF%AD%E8%A8%80%E7%AF%87_1/">C++2.0新特性_语言篇_1</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/25/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">胡少.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>