<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>opencv_lane_mark</title>
      <link href="2021/06/25/opencv-lane-mark/"/>
      <url>2021/06/25/opencv-lane-mark/</url>
      
        <content type="html"><![CDATA[<p>基于OpenCV的车道线检测算法<br><span id="more"></span></p><h1 id="基于OpenCV的车道线检测算法"><a href="#基于OpenCV的车道线检测算法" class="headerlink" title="基于OpenCV的车道线检测算法"></a>基于OpenCV的车道线检测算法</h1><h3 id="1-1-Canny的检测原理"><a href="#1-1-Canny的检测原理" class="headerlink" title="1.1 Canny的检测原理"></a>1.1 Canny的检测原理</h3><p>cv2.Canny(img,50,100)</p><p>Canny边缘检测是从不同视觉对象中<strong>提取有用的结构信息</strong>并<strong>大大减少要处理的数据量</strong>的一种技术，目前已广泛应用于各种计算机视觉系统。Canny发现，在不同视觉系统上对边缘检测的要求较为类似，因此，可以实现一种具有广泛应用意义的边缘检测技术。</p><ul><li>边缘检测的一般标准包括：</li></ul><p>① 以低的错误率检测边缘——尽可能准确的捕获图像中尽可能多的边缘</p><p>② 检测到的边缘应精确定位在真实边缘的中心。</p><p>③ 图像中给定的边缘应只被标记一次，并且在可能的情况下，图像的噪声不应产生假的边缘。边缘只要一个精确的点宽度。</p><ul><li><ul><li><strong>计算图像中每个像素点的梯度强度和方向；</strong></li></ul></li></ul><p>图像中边缘可以指向各个方向，Canny算法使用<strong>四个算子</strong>来检测图像中的水平、垂直和对角边缘。边缘检测的算子（<strong>如Roberts，Prewitt，Sobel等</strong>）返回<strong>水平Gx</strong>和<strong>垂直Gy</strong>方向的<strong>一阶导数值</strong>，由此便可以确定像素点的梯度G和方向 <img src="https://www.zhihu.com/equation?tex=%5Ctheta+" alt="[公式]"> 。</p><p>其中Sx表示x方向的Sobel算子，用于检测y方向的边缘； Sy表示y方向的Sobel算子，用于检测x方向的边缘（边缘方向和梯度方向垂直）。</p><ul><li><ul><li><strong>使用Non-Maximum Suppression（非极大值抑制）消除边缘检测带来的杂散响应；</strong></li></ul></li></ul><p>如果直接把梯度作为边缘的话，将得到一个粗边缘的图像，在图像边缘区域，其附近梯度值往往都很大，这不满足上面提到的准则（最小响应标准），我们希望得到定位准确的单像素的边缘，<strong>所以将每个像素点的梯度与其梯度方向上的相邻像素比较，如果不是极大值，将其置0</strong>，<strong>否则置为某一不大于255的数</strong>，非最大值抑制能帮助保留局部最大梯度而抑制所有其他梯度值。</p><ul><li><ul><li><strong>使用Double-Threshold（双阈值）检测确定真实和潜在的边缘；</strong></li><li><strong>通过抑制鼓励的弱边缘最终完成边缘检测.</strong></li></ul></li></ul><p>这个阶段决定哪些边缘是真正的边缘，哪些不是边缘。为此，我们需要两个阈值minVal和maxVal。强度梯度大于maxVal的任何边缘肯定是边缘，低于minVal的边缘肯定是非边缘，因此被丢弃。那些位于这两个阈值之间的点，<strong>则基于这些点是否与真正的边缘部分相连接如果它们连接到“真正边缘”像素，则它们被认为是边缘的一部分。否则，他们也被丢弃</strong>。</p><h2 id="2-做Segment"><a href="#2-做Segment" class="headerlink" title="2. 做Segment"></a>2. 做Segment</h2><h3 id="2-1-方法"><a href="#2-1-方法" class="headerlink" title="2.1 方法"></a>2.1 方法</h3><p>Segment的主要思想是，构建一个mask，这个mask包含主要的车道区域值均为1，其余为0，将这个mask与原frame进行叠加，就可以抠出主要的车道区域。</p><p>cv2.fillPolyy(mask,np.arry(),color=255)</p><p>cv2.bitwise_and(mask,edge_img);</p><h2 id="3-做霍夫变换"><a href="#3-做霍夫变换" class="headerlink" title="3.做霍夫变换"></a>3.做霍夫变换</h2><h3 id="3-1-Hough-Transform原理"><a href="#3-1-Hough-Transform原理" class="headerlink" title="3.1 Hough Transform原理"></a>3.1 Hough Transform原理</h3><p>霍夫变换(Hough Transform)是图像处理中的一种<strong>特征提取技术</strong>，常用来在图像中提取直线和圆等几何形状，该过程在一个参数空间中通过计算累计结果的局部最大值得到一个符合该特征的集合作为霍夫变换的结果。</p><p>lines= cv2.HoughtLinesP(edge_img,1,np.pi/180,15,minLinelength=40,macLineGap=20)</p><h3 id="4-标定车道边界"><a href="#4-标定车道边界" class="headerlink" title="4. 标定车道边界"></a>4. 标定车道边界</h3><h3 id="4-1-基本方法"><a href="#4-1-基本方法" class="headerlink" title="4.1 基本方法"></a>4.1 基本方法</h3><p>将从hough检测到的多条线平均成一条线表示车道的左边界， 一条线表示车道的右边界。基本思想很简单，<strong>就是先将霍夫变换的线段转换为一维信息，进行多项式拟合，在将得到的截距和斜率信息进行平均，在利用数值代换转换成cv坐标系的左边界线，和右边界线</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDMap</title>
      <link href="2021/06/24/HDMap/"/>
      <url>2021/06/24/HDMap/</url>
      
        <content type="html"><![CDATA[<p>高精度地图概述<br><span id="more"></span></p><h1 id="HD-Map"><a href="#HD-Map" class="headerlink" title="HD Map"></a>HD Map</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>分为三层：</p><ul><li><p>静态底图：</p><ol><li>定位图层:定位特征，杆状物，建筑、标牌等</li><li>车道图层：车道信息，道路标记、路沿、护栏等</li><li>线路图层：道路路网信息</li></ol></li><li><p>动态信息层</p><p>GPS定位信息</p></li><li><p>联网设施</p><p>v2x聪明的车和聪明的路，与高精度地图耦合</p></li></ul><h2 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h2><p><img src="F:\william\blog\source\_posts\HDMap\dataColloction.png" alt=""></p><p><img src="F:\william\blog\source\_posts\HDMap\theme.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> Driverless </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点云滤波</title>
      <link href="2021/06/24/Pointcloudlibrary/"/>
      <url>2021/06/24/Pointcloudlibrary/</url>
      
        <content type="html"><![CDATA[<p>PCL库点云滤波介绍<br><span id="more"></span></p><h1 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h1><h2 id="3D-features-in-Pcl"><a href="#3D-features-in-Pcl" class="headerlink" title="3D features in Pcl"></a>3D features in Pcl</h2><p><em>通过包括周围的邻居，可以推断和捕获潜在的采样表面几何在功能配方中，这有助于解决模糊比较问题。理想情况下，对于居住在相同或类似表面的点，由此产生的特征将非常相似（与某些指标有关），对于在不同表面上发现的点会有所不同，如下图所示。**</em>良好的<strong>*点功能表示能够</strong>在下*：</p><ul><li><strong>刚性转换</strong>-<em>即数据中的 3D 自转和 3D 转换不应影响由此产生的功能矢量 F 估计：</em></li><li><strong>不同的采样密度</strong>-<em>原则上，或多或少密集的局部表面贴片应具有相同的特征矢量特征：</em></li><li><strong>噪声</strong>-<em>点功能表示必须在数据中存在轻度噪声的情况下在其功能矢量中保留相同或非常相似的值。</em></li></ul><h1 id="滤波器"><a href="#滤波器" class="headerlink" title="滤波器"></a>滤波器</h1><p><strong>直通滤波器</strong>：对于在空间分布有一定空间特征的点云数据，比如使用线结构光扫描的方式采集点云，沿z向分布较广，但x,y向的分布处于有限范围内。此时可使用直通滤波器，确定点云在x或y方向上的范围，可较快剪除离群点，达到第一步粗处理的目的。</p><p><strong>体素滤波器</strong>：体素的概念类似于像素，使用AABB包围盒将点云数据体素化，一般体素越密集的地方信息越多，噪音点及离群点可通过体素网格去除。另一方面如果使用高分辨率相机等设备对点云进行采集，往往点云会较为密集。过多的点云数量会对后续分割工作带来困难。体素滤波器可以达到向下采样同时不破坏点云本身几何结构的功能。</p><p><strong>统计滤波器：</strong>考虑到离群点的特征，则可以定义某处点云小于某个密度，既点云无效。计算每个点到其最近的k个点平均距离。则点云中所有点的距离应构成高斯分布。给定均值与方差，可剔除3∑之外的点。</p><p><strong>条件滤波</strong>：条件滤波器通过设定滤波条件进行滤波，有点分段函数的味道，当点云在一定范围则留下，不在则舍弃。</p><p><strong>半径滤波器</strong>：半径滤波器与统计滤波器相比更加简单粗暴。以某点为中心画一个圆计算落在该圆中点的数量，当数量大于给定值时，则保留该点，数量小于给定值则剔除该点。此算法运行速度快，依序迭代留下的点一定是最密集的，但是圆的半径和圆内点的数目都需要人工指定。</p><h2 id="PassThrough-filter-直通滤波器"><a href="#PassThrough-filter-直通滤波器" class="headerlink" title="PassThrough filter 直通滤波器"></a>PassThrough filter <strong>直通滤波器</strong></h2><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">  // Create the filtering object  pcl::PassThrough<pcl::PointXYZ> pass;  pass.setInputCloud (cloud);  pass.setFilterFieldName ("z");  pass.setFilterLimits (0.0, 1.0);  pass.setFilterFieldName("y");  pass.setFilterLimits(0.4, 0.9);  pass.setFilterFieldName("x");  pass.setFilterLimits(-0.8, 0.65);  //pass.setFilterLimitsNegative (true);  pass.filter (*cloud_filtered);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="VoxelGrid-filter-throngh-Downsampling-a-PointCloud-体素滤波器"><a href="#VoxelGrid-filter-throngh-Downsampling-a-PointCloud-体素滤波器" class="headerlink" title="VoxelGrid filter throngh Downsampling a PointCloud 体素滤波器"></a>VoxelGrid filter throngh Downsampling a PointCloud <strong>体素滤波器</strong></h2><p>我们将要呈现的类在输入点云数据上创建一个<em>3D voxel 网格</em>（将 voxel 网格视为空间中的一组小 3D 框）。然后，在每个<em>voxel（</em>即 3D 框）中，所有存在点将与其中心点进行近似（即<em>向下采样</em>）。这种方法比用 voxel 的中心近似它们慢一点，但它更准确地表示底层表面。</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">  // Create the filtering object  pcl::VoxelGrid<pcl::PCLPointCloud2> sor;  sor.setInputCloud (cloud);  sor.setLeafSize (0.01f, 0.01f, 0.01f);  sor.filter (*cloud_filtered);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Removing-outliers-using-a-StatisticalOutlierRemoval-filter"><a href="#Removing-outliers-using-a-StatisticalOutlierRemoval-filter" class="headerlink" title="Removing outliers using a StatisticalOutlierRemoval filter"></a>Removing outliers using a StatisticalOutlierRemoval filter</h1><p>对于每一点，我们计算它与所有邻居的平均距离。假设结果分布为平均值和标准偏差的高斯，所有平均距离超出全球距离平均值定义的间隔点和标准偏差均值和标准偏差均值可视为离群值，并从数据集中修剪。</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">  // Create the filtering object  pcl::StatisticalOutlierRemoval<pcl::PointXYZ> sor;  sor.setInputCloud (cloud);  sor.setMeanK (50);//每个点要分析的邻居数量设置为 50  sor.setStddevMulThresh (1.0);//标准偏差乘数设置为 1  sor.filter (*cloud_filtered);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Projecting-points-using-a-parametric-model-投影滤波"><a href="#Projecting-points-using-a-parametric-model-投影滤波" class="headerlink" title="Projecting points using a parametric model 投影滤波"></a>Projecting points using a parametric model 投影滤波</h1><p>将点投射到参数模型（例如平面、球体等）上。参数模型是通过一组系数给出的——就平面而言，通过其方程：ax+×cz=d=0。</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">    // 创建一个系数为X=Y=0,Z=1的平面    /* pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients());    coefficients->values.resize(4);    coefficients->values[0] = coefficients->values[1] = 0;    coefficients->values[2] = 1.0;    coefficients->values[3] = 0;    */    // 二维圆    /* pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients());    coefficients->values.resize(3);    coefficients->values[0] = coefficients->values[1] = 0;    coefficients->values[2] = 1.0;    */    // 三维直线    /* pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients());    coefficients->values.resize(6);    coefficients->values[0] = coefficients->values[1] = coefficients->values[2] = 0;    coefficients->values[3] = coefficients->values[4] = 0;     coefficients->values[5] = 1.0;    */    // 圆柱体    pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients());    coefficients->values.resize(7);    coefficients->values[0] = coefficients->values[1] = coefficients->values[2] = 0;    coefficients->values[3] = coefficients->values[4] = 0;    coefficients->values[5] = -1.0;    coefficients->values[6] = 0.5;    // 创建滤波器对象    pcl::ProjectInliers<pcl::PointXYZ> proj;    // proj.setModelType(pcl::SACMODEL_PLANE);    // proj.setModelType(pcl::SACMODEL_CIRCLE2D); // 二维圆    // proj.setModelType(pcl::SACMODEL_LINE); // 三维直线    proj.setModelType(pcl::SACMODEL_CYLINDER); // 圆柱体    proj.setInputCloud(cloud);    proj.setModelCoefficients(coefficients);    proj.filter(*cloud_projected);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Extracting-indices-from-a-PointCloud"><a href="#Extracting-indices-from-a-PointCloud" class="headerlink" title="Extracting indices from a PointCloud"></a>Extracting indices from a PointCloud</h1><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">while ()  &#123;      // Extract the inliers    extract.setInputCloud (cloud_filtered);    extract.setIndices (inliers);    extract.setNegative (false);    extract.filter (*cloud_p);    // Create the filtering object    extract.setNegative (true);    extract.filter (*cloud_f);    cloud_filtered.swap (cloud_f);  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Removing-outliers-using-a-Conditional-or-RadiusOutlier-removal"><a href="#Removing-outliers-using-a-Conditional-or-RadiusOutlier-removal" class="headerlink" title="Removing outliers using a Conditional or RadiusOutlier removal"></a>Removing outliers using a Conditional or RadiusOutlier removal</h1><p>此处主要介绍两种移除离群点的方式：ConditionalRemoval和RadiusOutlierRemoval，ConditionalRemoval用来删除点云中不满足一个或多个给定条件的所有索引，RadiusOutlierRemoval指在给定半径范围内，邻近点个数少于一定数量的点就会被移除。</p><p>ConditionalRemoval的使用方式如下：</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">// build the conditionpcl::ConditionAnd<pcl::PointXYZ>::Ptr range_cond(new pcl::ConditionAnd<pcl::PointXYZ>());range_cond->addComparison(pcl::FieldComparison<pcl::PointXYZ>::ConstPtr(new        pcl::FieldComparison<pcl::PointXYZ>("z", pcl::ComparisonOps::GT, 600.0)));range_cond->addComparison(pcl::FieldComparison<pcl::PointXYZ>::ConstPtr(new        pcl::FieldComparison<pcl::PointXYZ>("z", pcl::ComparisonOps::LT, 900.0)));// build the filterpcl::ConditionalRemoval<pcl::PointXYZ> condrem;condrem.setCondition(range_cond);condrem.setInputCloud(cloud);condrem.setKeepOrganized(true);// apply filtercondrem.filter(*cloud_filtered);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先需要通过pcl::ConditionAnd<pcl::PointXYZ>设定滤波的条件，在上面的代码里添加了2个比较的条件 Z&gt;600 &amp;&amp; Z&lt;900, 然后用此条件构造ConditionalRemoval滤波器，最后滤波后的点云存储在cloud_filtered中。</p><p>RadiusOutlierRemoval背景知识</p><p>以下图片有助于RadiusOutlierRemoval的理解，用户来指定点云中每个点在特定半径范围内必须有的邻近点个数，如果指定邻近点个数为1则灰色的点会被移除，假定指定邻近点个数为3则灰色和红色的点均会被移除</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">pcl::RadiusOutlierRemoval<pcl::PointXYZ> outrem;// build the filteroutrem.setInputCloud(cloud);outrem.setRadiusSearch(50.0);outrem.setMinNeighborsInRadius(50);// apply filteroutrem.filter(*cloud_filtered);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> PCL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pointnet++</title>
      <link href="2021/06/19/pointnet/"/>
      <url>2021/06/19/pointnet/</url>
      
        <content type="html"><![CDATA[<p>PointNet++ 论文及代码解读<br><span id="more"></span></p><h1 id="PointNet-论文及代码解读"><a href="#PointNet-论文及代码解读" class="headerlink" title="PointNet++ 论文及代码解读"></a>PointNet++ 论文及代码解读</h1><p><strong>Title：</strong>PointNet++:Deep Hierarchical Feature Learning on Point Sets in a Metric Space<br><strong>原文地址：</strong><a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1706.02413">https://arxiv.org/abs/1706.02413</a><br><strong>发表日期：</strong>NIPS 2017</p><p>解读<br>虽然这篇文章叫PointNet++，但和<a href="https://zhuanlan.zhihu.com/p/86331508">PointNet</a>相比还是有很大的改进。文章非常核心的一点就是提出了多层次特征提取结构。具体来说就是先在输入点集中选择一些点作为中心点，然后围绕每个中心点选择周围的点组成一个区域，之后每个区域作为PointNet的一个输入样本，得到一组特征，这个特征就是这个区域的特征。之后中心点不变，扩大区域，把上一步得到的那些特征作为输入送入PointNet，以此类推，这个过程就是不断的提取局部特征，然后扩大局部范围，最后得到一组全局的特征，然后进行分类。文章中还提出了多尺度的方法解决样本不均匀的问题，这些方法对于分类的精度没有贡献，但在样本很稀疏的时候的确能让模型更有鲁棒性。</p><p><strong>1.</strong> <strong>Abstract</strong></p><p>PointNet存在的一个缺点是无法获得局部特征，这使得它很难对复杂场景进行分析。在PointNet++中，作者通过两个主要的方法来进行改进，使得网络能更好的提取局部特征。第一，利用空间距离（metric space distances），使用PointNet对点集局部区域进行特征迭代提取，使其能够学到局部尺度越来越大的特征。第二，由于点集分布很多时候是不均匀的，如果默认是均匀的，会使得网络性能变差，所以作者提出了一种自适应密度的特征提取方法。通过以上两种方法，能够更高效的学习特征，也更有鲁棒性。</p><p><strong>2.</strong> <strong>Introduction</strong></p><p>在PointNet++中，作者利用所在空间的距离度量将点集划分（partition）为有重叠的局部区域（可以理解为patch）。在此基础上，首先在小范围中从几何结构中提取局部特征（浅层特征），然后扩大范围，在这些局部特征的基础上提取更高层次的特征，知道提取到整个点集的全局特征。可以发现，这个过程和CNN网络的特征提取过程类似，首先提取低级别的特征，随着感受野的增大，提取的特征level越来越高。</p><p>PointNet++需要解决两个关键的问题：第一，如何将点集划分为不同的区域；第二，如何利用特征提取器获取不同区域的局部特征。这两个问题实际上是相关的，要想通过特征提取器来对不同的区域进行特征提取，需要每个分区具有相同的结构。这里同样可以类比CNN来理解，在CNN中，卷积块作为基本的特征提取器，对应的区域都是n*n的像素区域。而在3D点集当中，同样需要找到结构相同的子区域，和对应的区域特征提取器。</p><p>在本文中，作者使用了PointNet作为特征提取器，另外一个问题就是如何来划分点集从而产生结构相同的区域。作者使用邻域球球来定义分区，或者也可以叫做patch，每个区域可以通过中心坐标和半径来确定。中心坐标的选取，作者使用了快速采样算法来完成（farthest point sampling (FPS) algorithm）。区域半径的选择是一个比较有挑战性的事情，因为输入点集是不均匀的，同时区域特征会存在重叠或被遗忘的情况。尽管在VGG当中提到，CNN使用小的卷积核效果比较好，但这是由于图像是网格化的，每个区域是非常规整的，如果再PointNet++使用小的半径，网络性能反而很差。这里可以从直观上想象一下，邻域球过小，可能意味着可能看不到足够完整的局部特征。这个过程也可是使用KNN实现。</p><p><strong>3. 网络结构</strong></p><p>PointNet++是PointNet的延伸，在PointNet的基础上加入了多层次结构（hierarchical structure），使得网络能够在越来越大的区域上提供更高级别的特征。</p><p><img src="F:\william\blog\source\_posts\pointnet\net.jpg" alt=""></p><p>网络的每一组set abstraction layers主要包括3个部分：Sampling layer, Grouping layer and PointNet layer。</p><blockquote><p><strong>· Sample layer：</strong>主要是对输入点进行采样，在这些点中选出若干个中心点（问题：怎么选，选多少个点？）<br><strong>· Grouping layer：</strong>是利用上一步得到的中心点将点集划分成若干个区域；<br><strong>· PointNet layer：</strong>是对上述得到的每个区域进行编码，变成特征向量。</p></blockquote><p>每一组提取层的输入是N<em>(d + C)，其中N是输入点的数量，d是坐标维度，C是特征维度。输出是N’</em>(d + C’)，其中N’是输出点的数量，d是坐标维度不变，C’是新的特征维度。下面详细介绍每一层的作用及实现过程。</p><p><strong>1). Sample layer</strong></p><p>使用farthest point sampling选择N’个点，至于为什么选择使用这种方法选择点，文中提到相比于随机采样，这种方法能更好的的覆盖整个点集。具体选择多少个中心点，数量怎么确定，是由人来指定的。</p><ul><li>最远点采样</li></ul><p>FPS算法的逻辑为：</p><ol><li><p>以点云第一个点，作为查询点，从剩余点中，取一个距离最远的点；</p></li><li><p>继续以取出来的点，作为查询点，从剩余点中，取距离最远的点。此时，由于已经取出来的点的个数大于1，需要考虑已经选出来的点集中的每个点。计算逻辑如下：</p></li><li><ol><li>对于任意一个剩余点，计算该点到已经选中的点集中所有点的距离；</li><li>取最小值，作为该点到点集的距离；</li><li>计算出每个剩余点到点集的距离后，取距离最大的那个点。</li></ol></li><li><p>重复第2步，一直采样到目标数量N为止。</p></li></ol><p><strong>2). Grouping layer</strong></p><p>这一层使用Ball query方法生成N’个局部区域，根据论文中的意思，这里有两个变量 ，一个是每个区域中点的数量K，另一个是球的半径。这里半径应该是占主导的，会在某个半径的球内找点，上限是K。球的半径和每个区域中点的数量都是人指定的。这一步也可以使用KNN来进行，而且两者的对于结果的影响并不大。</p><p><img src="F:\william\blog\source\_posts\pointnet\grouplayer.png" alt=""></p><p><strong>3). PointNet layer</strong></p><p>这一层是PointNet，接受N’×K×(d+C)的输入。输出是N’×(d+C)。需要注意的是，在输入到网络之前，会把该区域中的点变成围绕中心点的相对坐标。作者提到，这样做能够获取点与点之间的关系（对这一点存疑，但感觉有限像Batch Norm？）。</p><p><strong>4). 对于非均匀点云的处理方法</strong></p><p>点云不均匀时，每个子区域中如果在分区的时候使用相同的球半径，会导致有些稀疏区域采样点过小。这个地方插一点自己的想法，从一个角度来看，点云的疏密程度是不是可以看做样本属性的一部分？从这个意义上来讲这就不是一个需要克服的缺点。如果担心某些区域采样点过小，是否可以加一个阈值下限。</p><p>作者提到这个问题需要解决，并且提出了两个方法：Multi-scale grouping (MSG) and Multi-resolution grouping (MRG)。下面是论文当中的示意图。</p><p><img src="F:\william\blog\source\_posts\pointnet\ununiformpoint.jpg" alt=""></p><p>下面分别介绍一下这两种方法。第一种多尺度分组（MSG），对于同一个中心点，如果使用3个不同尺度的话，就分别找围绕每个中心点画3个区域，每个区域的半径及里面的点的个数不同。对于同一个中心点来说，不同尺度的区域送入不同的PointNet进行特征提取，之后concat，作为这个中心点的特征。也就是说MSG实际上相当于并联了多个hierarchical structure，每个结构中心点数量一样，但是区域范围不同（可以理解成感受野？），PointNet的输入和输出尺寸也不同，然后几个不同尺度的结构在PointNet有一个Concat。</p><p><img src="F:\william\blog\source\_posts\pointnet\msg.jpg" alt=""></p><p>另一种是多分辨率分组（MRG)。MSG很明显会影响降低运算速度，所以提出了MRG，这种方法应该是对不同level的grouping做了一个concat，但是由于尺度不同，对于low level的先放入一个pointnet进行处理再和high level的进行concat。感觉和ResNet中的跳连接有点类似。</p><p>在这部分，作者还提到了一种random input dropout（DP）的方法，就是在输入到点云之前，对点集进行随机的Dropout,比例使用了95%，也就是说进行95%的重新采样。某种程度有点像数据增强，也是提高模型的robustness。那这些方法效果怎么样呢，我们一起来看一下。</p><p>从论文中的这幅分类实验结果图可以看出来，多尺度（MSG,MRG)和单一尺度相比（SSG）对分类的准确率没有什么提升，有一个好处是如果点云很稀疏的话，使用MSG可以保持很好的robustness。对于robustness效果random input dropout（DP）其实贡献更大。</p><p><img src="F:\william\blog\source\_posts\pointnet\compare.jpg" alt=""></p><p>从论文中的分割实验结果看，使用（MSG+DP）之后的确是比SSG结果提升了，在非均匀点云上差距会大一点，但是作者并没有给出MSG和DP对于效果提升单独的贡献对比，所以我们很难确定到底是MSG还是DP在这其中起作用了。</p><p><img src="F:\william\blog\source\_posts\pointnet\accuracy.jpg" alt=""></p><p><strong>4. 通过代码理解核心结构</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> PointCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gfzrnx</title>
      <link href="2021/06/11/gfzrnx/"/>
      <url>2021/06/11/gfzrnx/</url>
      
        <content type="html"><![CDATA[<p>gfz批处理工具下载<br><span id="more"></span></p><h1 id="gazrnx工具及批处理工具下载"><a href="#gazrnx工具及批处理工具下载" class="headerlink" title="gazrnx工具及批处理工具下载"></a>gazrnx工具及批处理工具下载</h1><p><a href="/download/gfzrnx batch_v1.rar">下载链接</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>轨道平顺性概念介绍</title>
      <link href="2021/05/20/highspeedrailway/"/>
      <url>2021/05/20/highspeedrailway/</url>
      
        <content type="html"><![CDATA[<p>文章介绍了轨道平顺性的基本概念并进行了编程实现<br><span id="more"></span></p><h2 id="轨距"><a href="#轨距" class="headerlink" title="轨距"></a>轨距</h2><img src="/2021/05/20/highspeedrailway/1.jpg" class=""><p>轨道两侧AB点间的距离：</p><script type="math/tex; mode=display">A\left(x_{1}, y_{1}, z_{1}\right), \quad B\left(x_{2}, y_{2}, z_{2}\right)</script><script type="math/tex; mode=display">|A B|=\sqrt{\left(x_{1}-x_{2}\right)^{2}+\left(y_{1}-y_{2}\right)^{2}+\left(z_{1}-z_{2}\right)^{2}}</script><p>则两期轨距变化量为：</p><script type="math/tex; mode=display">\Delta|A B|=|A B|^{2}-|A B|^{1}</script><h2 id="水平（超高）"><a href="#水平（超高）" class="headerlink" title="水平（超高）"></a>水平（超高）</h2><img src="/2021/05/20/highspeedrailway/2.jpg" class=""><p>轨道两侧AB点间的距离：</p><script type="math/tex; mode=display">A\left(x_{1}, y_{1}, z_{1}\right), \quad B\left(x_{2}, y_{2}, z_{2}\right)</script><script type="math/tex; mode=display">\Delta h=z_{2}-z_{1}</script><p>则两期轨距变化量（有方向）为：</p><script type="math/tex; mode=display">\Delta H=\Delta h^{2}-\Delta h^{1}</script><h2 id="高低"><a href="#高低" class="headerlink" title="高低"></a>高低</h2><p>高低是指钢轨的顶面垂直方向上高于或低于理论轨面的差值，反应了轨道线路的垂直方向的凹凸不平顺性。如上图所示，为高低的测量计算原理：</p><img src="/2021/05/20/highspeedrailway/3.png" class=""><p>根据P<sub>1</sub> 到P<sub>17</sub> 各个测量点的坐标求解出对应的里程和高程，然后以里程为X 轴坐标，高程为Y 轴坐标，建立平面坐标系。通过P<sub>1</sub> 点和P<sub>17</sub> 点的坐标计算直线P<sub>1</sub> 与P<sub>17</sub> 的直线方程，然后将P<sub>9</sub> 点投影都直线上，得出投影失距s：</p><p>设P<sub>i</sub>，P<sub>i+8</sub>，P<sub>i+16</sub>坐标依次为：</p><script type="math/tex; mode=display">P_{i}\left(x_{i}, y_{i}, z_{i}\right)，P_{i+8}\left(x_{i+8}, y_{i+8}, z_{i+8}\right)，P_{i+16}\left(x_{i+16}, y_{i+16}, z_{i+16}\right)</script><p>则高低计算公式为：</p><script type="math/tex; mode=display">s=\frac{\left(x_{i}-x_{i+16}\right){*}\left(z_{i}{*}\left(x_{i+8}-x_{i+16}\right)-z_{i+16} *\left(x_{i+8}-x_{i}\right)\right)+\left(y_{i}-y_{i+16}\right){*}\left(z_{i}{*}\left(y_{i+8}-y_{i+16}\right)-z_{i+16} *\left(y_{i+8}-y_{i}\right)\right)}{\left(\left(x_{i}-x_{i+16}\right)^{2}+\left(y i-y_{i+16}\right)^{2}\right)-z_{i+8}}</script><p>两期高低变化量为：</p><script type="math/tex; mode=display">\Delta s= s^{2}- s^{1}</script><h2 id="轨向"><a href="#轨向" class="headerlink" title="轨向"></a>轨向</h2><img src="/2021/05/20/highspeedrailway/4.jpg" class=""><p>轨向（正矢）指的是轨道的中心轴线在水平面上的平顺度。</p><p>设P<sub>i</sub>，P<sub>i+8</sub>，P<sub>i+16</sub>坐标依次为：</p><script type="math/tex; mode=display">P_{i}\left(x_{i}, y_{i}, z_{i}\right)，P_{i+8}\left(x_{i+8}, y_{i+8}, z_{i+8}\right)，P_{i+16}\left(x_{i+16}, y_{i+16}, z_{i+16}\right)</script><p>则高低计算公式为：</p><script type="math/tex; mode=display">s=\frac{\left(\mathrm{y}_{\mathrm{i}+16}-\mathrm{y}_{\mathrm{i}}\right) * \mathrm{x}_{\mathrm{i}+8}+\left(\mathrm{x}_{\mathrm{i}}-\mathrm{x}_{\mathrm{i}+16}\right) * \mathrm{y}_{\mathrm{i}+8}+\mathrm{x}_{\mathrm{i}+16} * \mathrm{y}_{\mathrm{i}}-\mathrm{x}_{\mathrm{i}} * \mathrm{y}_{\mathrm{i}+16}}{\sqrt{\left(\mathrm{x}_{\mathrm{i}}-\mathrm{x}_{\mathrm{i}+16}\right)^{2} +\left(\mathrm{y}_{\mathrm{i}}-\mathrm{y}_{\mathrm{i}+16}\right)^{2} } }</script><p>两期轨向变化量：</p><script type="math/tex; mode=display">\Delta s= s^{2}- s^{1}</script><h2 id="三角坑（扭曲）"><a href="#三角坑（扭曲）" class="headerlink" title="三角坑（扭曲）"></a>三角坑（扭曲）</h2><img src="/2021/05/20/highspeedrailway/5.png" class=""><p>根据《铁路线路维修规则》，以弦长3m为标准，选取四个测量点P<sub>1</sub>、 P<sub>2</sub>、P<sub>3</sub>、 P<sub>4</sub>如图 3-6 中所示，图上的情况为最不理想的情况。设他们各自的实测高<br>程分别为H<sub>1</sub>、 H<sub>2</sub>、H<sub>3</sub>、 H<sub>4</sub>，则轨道扭曲平顺性测量公式为：</p><script type="math/tex; mode=display">H=\left(H_{1}-H_{2}\right)-\left(H_{3}-H_{4}\right)</script><p>两期扭曲变化量：</p><script type="math/tex; mode=display">\Delta H= H^{2}- H^{1}</script>]]></content>
      
      
      
        <tags>
            
            <tag> article </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx源码概览</title>
      <link href="2021/04/15/Nginx%E4%B8%AD%E7%9A%84%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>2021/04/15/Nginx%E4%B8%AD%E7%9A%84%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>90分钟NGINX锁的使用<br><span id="more"></span></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>1、nginx应用场景：静态web服务、反向代理、正向代理、负载均衡；</p><p>2、nginx实现代理功能的基石：accept锁</p><p>3、nginx实现文件操作的基石：线程池+自旋锁+信号量+互斥锁+条件变量</p><h2 id="1、NGINX应用场景"><a href="#1、NGINX应用场景" class="headerlink" title="1、NGINX应用场景"></a>1、NGINX应用场景</h2><p>nginx.conf</p><p>worker_processes 线程数目和CPU核心对应；</p><ul><li><p>反向均衡</p><p>1、服务器处理能力不一致，分配不一样的权重</p><p>2、服务器能力一致，最小连接数（共享内存）</p><p>3、为在客户端断开重连后依然能连接到该服务采用IPhash</p></li><li><p>如何保存最小连接数</p></li><li><p>多进程监听一个端口8888（加锁（共享内存））</p></li><li><p>锁放在共享内存中，epoll_wait();listend</p></li><li><p>work进程如何拿锁？</p></li></ul><h2 id="2、accept锁"><a href="#2、accept锁" class="headerlink" title="2、accept锁"></a>2、accept锁</h2><p>1、互斥锁10ms</p><p>2、自旋锁-&gt;原子操作</p><ul><li>没有发生线程切换</li><li>连接数多的话，采用自旋锁</li><li>连接数少的话，避免CPU空转，</li></ul><p>3、读写锁</p><p>4、条件变量</p><p>5、cas锁</p><p>连接数少的情况下：</p><p>自旋锁空转CPU一定时间后，如果仍然没有拿到锁的话，通过信号量（NGX_HAVE_POSIX_SEM）让出CPU（sem_wait阻塞让出CPU）</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">//信号量//多层级高性能缓存设计//sem_intit(set *sem,int pshared, unsingned int value); value = 0;case  pshared==0多线程case  pshared ==1 关联进程value //信号量资源数默认为0；sem_wait,se_timedwait,sem_trywait-lock a semaphore //讲上面的value减一<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>突然连接数变多的情况：</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">sem_post - unlocak a semphorevalue++;ngx_shmtx_wakeup(ngx_shmtx_t *mtx)ngx_shmtx_unlock(ngx_shmtx_t *mtx)if(ngx_use_accept_mutex) 连接数多的情况调用unlock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、NGINX实现文件操作的基石"><a href="#3、NGINX实现文件操作的基石" class="headerlink" title="3、NGINX实现文件操作的基石"></a>3、NGINX实现文件操作的基石</h2><p>任务队列和完成队列，自旋锁，push pop操作简单</p><p>任务数少，任务数多的情况，线程池</p><p>信号量？？？不行，初始值是固定的，任务数不行，只能使用条件变量，信号量可以解决的问题条件变量（多线程）都可以处理， 除了多进程。</p><p>通过条件变量去管理线程池，任务数少，休眠，反之则唤醒；</p><h1 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h1><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">int socket(int domain, int type, int protocol);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li><li>type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。</li><li>protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议（这个协议我将会单独开篇讨论！）。</li></ul><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。</li><li>addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同.</li><li>addrlen：对应的是地址的长度。</li></ul><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">int listen(int sockfd, int backlog);int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p></li><li><p>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</p></li></ul><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p><p>注意：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p><h1 id="reactor模型"><a href="#reactor模型" class="headerlink" title="reactor模型"></a>reactor模型</h1><p>1、事件驱动</p><p>2、处理一个或多个并发传递到服务端的服务请求</p><p>3、对传入的请求进行解复用并同步分派给关联handler</p><p>非阻塞IO+IO多路复用</p><h1 id="libevent"><a href="#libevent" class="headerlink" title="libevent"></a>libevent</h1><p>优点：跨平台，IO转event，忽略函数返回值，三个事件</p><p>针对reactor的封装，将网络io处理 转化为 事件处理</p><p>event 事件， event_base事件管理器</p><p>注册（event add）+检测+分派(callback)</p><p>网络编程如何学习：闭源——顺藤摸瓜，顺瓜摸藤</p><p>//对于服务端有三种事件1、网络事件2、定时事件3、信号事件 kill -9 pid</p><p>//log 系统 写日志，文件写不进去了，调试fd可用，日志重定向出现异常，内核以信号方式通知应用程序，捕获这个信号， fd重定向后可以打开</p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/01/25/threadpool/"/>
      <url>2021/01/25/threadpool/</url>
      
        <content type="html"><![CDATA[<p>threadpool介绍<br><span id="more"></span></p><h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><p>&nbsp;<a href="https://github.com/mtrebi/thread-pool/blob/master/README.md#introduction">Introduction</a>  <br/><br>&nbsp;<a href="https://github.com/mtrebi/thread-pool/blob/master/README.md#build-instructions">Build instructions</a>  <br/><br>&nbsp;<a href="https://github.com/mtrebi/thread-pool/blob/master/README.md#thread-pool">Thread pool</a><br/><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/mtrebi/thread-pool/blob/master/README.md#queue">Queue</a><br/><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/mtrebi/thread-pool/blob/master/README.md#submit-function">Submit function</a>  <br/><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/mtrebi/thread-pool/blob/master/README.md#thread-worker">Thread worker</a>  <br/><br>&nbsp;<a href="https://github.com/mtrebi/thread-pool/blob/master/README.md#usage-example">Usage example</a>  <br/><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/mtrebi/thread-pool#use-case-1">Use case#1</a>  <br/><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/mtrebi/thread-pool#use-case-2">Use case#2</a>  <br/><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/mtrebi/thread-pool#use-case-3">Use case#3</a>  <br/><br>&nbsp;<a href="https://github.com/mtrebi/thread-pool/blob/master/README.md#future-work">Future work</a>  <br/><br>&nbsp;<a href="https://github.com/mtrebi/thread-pool/blob/master/README.md#references">References</a>  <br/> </p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction:"></a>Introduction:</h1><p>A <a href="https://en.wikipedia.org/wiki/Thread_pool">thread pool</a> is a technique that allows developers to exploit the concurrency of modern processors in an <strong>easy</strong> and <strong>efficient</strong> manner. It’s easy because you send “work” to the pool and somehow this work gets done without blocking the main thread. It’s efficient because threads are not initialized each time we want the work to be done. Threads are initialized once and remain inactive until some work has to be done. This way we minimize the overhead.</p><p>There are many more Thread pool implementations in C++, many of them are probably better (safer, faster…) than mine. However,I believe my implementation are <strong>very straightforward and easy to understand</strong>. </p><p><strong>Disclaimer: Please Do not use this project in a professional environment. It may contain bugs and/or not work as expected.</strong> I did this project to learn how C++11 Threads work and provide an easy way for other people to understand it too. </p><h1 id="Build-instructions"><a href="#Build-instructions" class="headerlink" title="Build instructions:"></a>Build instructions:</h1><p>This project has been developed using Netbeans and Linux but it should work on Windows, MAC OS and Linux. It can be easily build using CMake and different other generators. The following code can be used to generate the VS 2017 project files:</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">// VS 2017cd <project-folder>mkdir buildcd build/cmake .. "Visual Studio 15 2017 Win64"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Then, from VS you can edit and execute the project. Make sure that <strong>main project is set up as the startup project</strong></p><p>If you are using Linux, you need to change the generator (use the default) and execute an extra operation to actually make it executable:</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">// Linuxcd <project-folder>mkdir buildcd build/cmake ..make<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Thread-pool"><a href="#Thread-pool" class="headerlink" title="Thread pool"></a>Thread pool</h1><p>The way that I understand things better is with images. So, let’s take a look at the image of thread pool given by Wikipedia:</p><p align="center">  <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/0c/Thread_pool.svg/580px-Thread_pool.svg.png"> </p><p>As you can see, we have three important elements here:</p><ul><li><em>Tasks Queue</em>. This is where the work that has to be done is stored.</li><li><em>Thread Pool</em>. This is set of threads (or workers) that continuously take work from the queue and do it.</li><li><em>Completed Tasks</em>. When the Thread has finished the work we return “something” to notify that the work has finished.</li></ul><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>We use a queue to store the work because it’s the more sensible data structure. We want the work to be <strong>started</strong> in the same order that we sent it. However, this queue is a little bit <strong>special</strong>. As I said in the previous section, threads are continuously (well, not really, but let’s assume that they are) querying the queue to ask for work. When there’s work available, threads take the work from the queue and do it. What would happen if two threads try to take the same work at the same time? Well, the program would crash.</p><p>To avoid these kinds of problems, I implemented a wrapper over the standard C++ Queue that uses mutex to restrict the concurrent access. Let’s see a small sample of the SafeQueue class:</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">void enqueue(T& t) &#123;    std::unique_lock<std::mutex> lock(m_mutex);    m_queue.push(t);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>To enqueue the first thing we do is lock the mutex to make sure that no one else is accessing the resource. Then, we push the element to the queue. When the lock goes out of scopes it gets automatically released. Easy, huh? This way, we make the Queue thread-safe and thus we don’t have to worry many threads accessing and/or modifying it at the same “time”.</p><h2 id="Submit-function"><a href="#Submit-function" class="headerlink" title="Submit function"></a>Submit function</h2><p>The most important method of the thread pool is the one responsible of adding work to the queue. I called this method <strong>submit</strong>. It’s not difficult to understand how it works but its implementation can seem scary at first. Let’s think about <strong>what</strong> should do and after that we will worry about <strong>how</strong> to do it. What:</p><ul><li>Accept any function with any parameters.</li><li>Return “something” immediately to avoid blocking main thread. This returned object should <strong>eventually</strong> contain the result of the operation.</li></ul><p>Cool, let’s see <strong>how</strong> we can implement it.</p><h3 id="Submit-implementation"><a href="#Submit-implementation" class="headerlink" title="Submit implementation"></a>Submit implementation</h3><p>The complete submit functions looks like this:</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">// Submit a function to be executed asynchronously by the pooltemplate<typename F, typename...Args>auto submit(F&& f, Args&&... args) -> std::future<decltype(f(args...))> &#123;    // Create a function with bounded parameters ready to execute    std::function<decltype(f(args...))()> func = std::bind(std::forward<F>(f), std::forward<Args>(args)...);    // Encapsulate it into a shared ptr in order to be able to copy construct / assign     auto task_ptr = std::make_shared<std::packaged_task<decltype(f(args...))()>>(func);    // Wrap packaged task into void function    std::function<void()> wrapper_func = [task_ptr]() &#123;      (*task_ptr)();     &#125;;    // Enqueue generic wrapper function    m_queue.enqueue(wrapperfunc);    // Wake up one thread if its waiting    m_conditional_lock.notify_one();    // Return future from promise    return task_ptr->get_future();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Nevertheless, we’re going to inspect line by line what’s going on in order to fully understand how it works. </p><h4 id="Variadic-template-function"><a href="#Variadic-template-function" class="headerlink" title="Variadic template function"></a>Variadic template function</h4><pre class="line-numbers language-lang-c"><code class="language-lang-c">template<typename F, typename...Args><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>This means that the next statement is templated. The first template parameter is called F (our function) and second one is a parameter pack. A parameter pack is a special template parameter that can accept zero or more template arguments. It is, in fact, a way to express a variable number of arguments in a template. A template with at least one parameter pack is called <strong>variadic template</strong></p><p>Summarizing, we are telling the compiler that our submit function is going to take one generic parameter of type F (our function) and a parameter pack Args (the parameters of the function F).</p><h4 id="Function-declaration"><a href="#Function-declaration" class="headerlink" title="Function declaration"></a>Function declaration</h4><pre class="line-numbers language-lang-c"><code class="language-lang-c">auto submit(F&& f, Args&&... args) -> std::future<decltype(f(args...))> &#123;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>This may seem weird but, it’s not. A function, in fact, can be declared using two different syntaxes. The following is the most well known:</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">return-type identifier ( argument-declarations... )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>But, we can also declare the function like this:</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">auto identifier ( argument-declarations... ) -> return_type<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Why two syntaxes? Well, imagine that you have a function that has a return type that depends on the input parameters of the function. Using the first syntax you can’t declare that function without getting a compiler error since you  would be using a variable in the return type that has not been declared yet (because the return type declaration goes before the parameters type declaration). </p><p>Using the second syntax you can declare the function to have return type <strong>auto</strong> then, using the -&gt; you can declare the return type depending on the arguments of the functions that have been declared previously. </p><p>Now, let’s inspect the parameters of the submit function. When the type of a parameter is declared as <strong>T&amp;&amp;</strong> for some deducted type T that parameter is a <strong>universal reference</strong>. This term was coined by <a href="https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">Scott Meyers</a> because <strong>T&amp;&amp;</strong> can also mean r-value reference. However, in the context of type deduction, it means that it can be bound to both l-values and r-values, unlike l-value references that can only be bound to non-const objects (they bind only to modifiable lvalues) and r-value references (they bind only to rvalues).</p><p>The return type of the function is of type <strong>std::future<T></strong>. An std::future is a special type that provides a mechanism to access the result of asynchronous operations, in our case, the result of executing a specific function. This makes sense with what we said earlier.</p><p>Finally, the template type of std::future is <strong>decltype(f(args…))</strong>. Decltype is a special C++ keyword that inspects the declared type of an entity or the type and value category of an expression. In our case, we want to know the return type of the function _f_, so we give decltype our generic function _f_ and the parameter pack _args_.</p><h4 id="Function-body"><a href="#Function-body" class="headerlink" title="Function body"></a>Function body</h4><pre class="line-numbers language-lang-c"><code class="language-lang-c">// Create a function with bounded parameters ready to executestd::function<decltype(f(args...))()> func = std::bind(std::forward<F>(f), std::forward<Args>(args)...);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>There are many many things happening here. First of all, the <strong>std::bind(F, Args)</strong> is a function that creates a wrapper for F with the given Args. Caling this wrapper is the same as calling F with the Args that it has been bound. Here, we are simply calling bind with our generic function _f_ and the parameter pack _args_ but using another wrapper <strong>std::forward<T>(t)</strong> for each parameter. This second wrapper is needed to achieve perfect forwarding of universal references.<br>The result of this bind call is a <strong>std::function<T></strong>. The std::function<T> is a C++ object that encapsulates a function. It allows you to execute the function as if it were a normal function calling the operator() with the required parameters BUT, because it is an object, you can store it, copy it and move it around. The template type of any std::function is the signature of that function: std::function&lt; return-type (arguments)&gt;. In this case, we already know how to get the return type of this function using decltype. But, what about the arguments? Well, because we bound all arguments _args_ to the function _f_ we just have to add an empty pair of parenthesis that represents an empty list of arguments: <strong>decltype(f(args…))()</strong>.</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">// Encapsulate it into a shared ptr in order to be able to copy construct / assign auto task_ptr = std::make_shared<std::packaged_task<decltype(f(args...))()>>(func);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>The next thing we do is we create a <strong>std::packaged_task<T>(t)</strong>.  A packaged_task is a wrapper around a function that can be executed asynchronously. It’s result is stored in a shared state inside an std::future<T> object. The templated type T of an std::packaged_task<T>(t) is the type of the function _t_ that is wrapping. Because we said it before, the signature of the function _f_ is <strong>decltype(f(args…))()</strong> that is the same type of the packaged_task. Then, we just wrap again this packaged task inside a <strong>std::shared_ptr</strong> using the initialize function <strong>std::make_shared</strong>.</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">// Wrap packaged task into void functionstd::function<void()> wrapperfunc = [task_ptr]() &#123;  (*task_ptr)(); &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Again, we create a std:.function, but, note that this time its template type is <strong>void()</strong>. Independently of the function _f_ and its parameters _args_ this _wrapperfunc_ the return type will always be <strong>void</strong>. Since all functions _f_ may have different return types, the only way to store them in a container (our Queue) is wrapping them with a generic void function. Here, we are just declaring this _wrapperfunc_ to execute the actual task _taskptr_ that will execute the bound function _func_.</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">// Enqueue generic wrapper functionm_queue.enqueue(wrapperfunc);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>We enqueue this _wrapperfunc_. </p><pre class="line-numbers language-lang-c"><code class="language-lang-c">// Wake up one thread if its waitingm_conditional_lock.notify_one();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Before finishing, we wake up one thread in case it is waiting.</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">// Return future from promisereturn task_ptr->get_future();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>And finally, we return the future of the packaged_task. Because we are returning the future that is bound to the packaged_task _taskptr_ that, at the same time, is bound with the function _func_, executing this _taskptr_ will automatically update the future. Because we wrapped the execution of the _taskptr_ with a generic wrapper function, is the execution of _wrapperfunc_ that, in fact, updates the future. Aaaaand. since we enqueued this wrapper function, it will be executed by a thread after being dequeued calling the operator().</p><h2 id="Thread-worker"><a href="#Thread-worker" class="headerlink" title="Thread worker"></a>Thread worker</h2><p>Now that we understand how the submit method works, we’re going to focus on how the work gets done. Probably, the simplest implementation of a thread worker could be using polling:</p><pre><code> Loop    If Queue is not empty        Dequeue work        Do it</code></pre><p>This looks alright but it’s <strong>not very efficient</strong>. Do you see why? What would happen if there is no work in the Queue? The threads would keep looping and asking all the time: Is the queue empty? </p><p>The more sensible implementation is done by “sleeping” the threads until some work is added to the queue. As we saw before, as soon as we enqueue work, a signal <strong>notify_one()</strong> is sent. This allows us to implement a more efficient algorithm:</p><pre><code>Loop    If Queue is empty        Wait signal    Dequeue work    Do it</code></pre><p>This signal system is implemented in C++ with <strong>conditional variables</strong>. Conditional variables are always bound to a mutex, so I added a mutex to the thread pool class just to manage this. The final code of a worker looks like this: </p><pre class="line-numbers language-lang-c"><code class="language-lang-c">void operator()() &#123;    std::function<void()> func;    bool dequeued;    while (!m_pool->m_shutdown) &#123;    &#123;        std::unique_lock<std::mutex> lock(m_pool->m_conditional_mutex);        if (m_pool->m_queue.empty()) &#123;            m_pool->m_conditional_lock.wait(lock);        &#125;        dequeued = m_pool->m_queue.dequeue(func);    &#125;        if (dequeued) &#123;              func();        &#125;    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>The code is really easy to understand so I am not going to explain anything. The only thing to note here is that, _func_ is our wrapper function declared as:</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">std::function<void()> wrapperfunc = [task_ptr]() &#123;  (*task_ptr)(); &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>So, executing this function will automatically update the future.</p><h1 id="Usage-example"><a href="#Usage-example" class="headerlink" title="Usage example"></a>Usage example</h1><p>Creating the thread pool is as easy as:</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">// Create pool with 3 threadsThreadPool pool(3);// Initialize poolpool.init();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>When we want to shutdown the pool just call:</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">// Shutdown the pool, releasing all threadspool.shutdown()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Ff we want to send some work to the pool, after we have initialized it, we just have to call the submit function:</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">pool.submit(work);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Depending on the type of work, I’ve distinguished different use-cases. Suppose that the work that we have to do is multiply two numbers. We can do it in many different ways. I’ve implemented the three most common ways to do it that I can imagine:</p><ul><li>Use-Case #1. Function returns the result</li><li>Use-Case #2. Function updates by ref parameter with the result</li><li>Use-Case #3. Function prints the result</li></ul><p>_Note: This is just to show how the submit function works. Options are not exclusive_</p><h2 id="Use-Case-1"><a href="#Use-Case-1" class="headerlink" title="Use-Case #1"></a>Use-Case #1</h2><p>The multiply function with a return looks like this:</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">// Simple function that adds multiplies two numbers and returns the resultint multiply(const int a, const int b) &#123;  const int res = a * b;  return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Then, the submit:</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">// The type of future is given by the return type of the functionstd::future<int> future = pool.submit(multiply, 2, 3);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>We can also use the <strong>auto</strong> keyword for convenience:</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">auto future = pool.submit(multiply, 2, 3);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Nice, when the work is finished by the thread pool we know that the future will get updated and we can retrieve the result calling:</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">const int result = future.get();std::cout << result << std::endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>The get() function of std::future<T> always return the type T of the future. <strong>This type will always be equal to the return type of the function passed to the submit method</strong>. In this case, int.</p><h2 id="Use-Case-2"><a href="#Use-Case-2" class="headerlink" title="Use-Case #2"></a>Use-Case #2</h2><p>The multiply function has a parameter passed by ref:</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">// Simple function that adds multiplies two numbers and updates the out_res variable passed by refvoid  multiply(int& out_res, const int a, const int b) &#123;    out_res = a * b;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Now, we have to call the submit function with a subtle difference. Because we are using templates and type deduction (universal references), the parameter passed by ref needs to be called using <strong>std::ref(param)</strong> to make sure that we are passing it by ref and not by value.</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">int result = 0;auto future = pool.submit(multiply, std::ref(result), 2, 3);// result is 0future.get();// result is 6std::cout << result << std::endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>In this case, what’s the type of future? Well, as I said before, the return type will always be equal to the return type of the function passed to the submit method. Because this function is of type void, the future  is <strong>std::future<void></strong>. Calling future.get() returns void. That’s not very useful, but we still need to call .get() to make sure that the work has been done.</p><h2 id="Use-Case-3"><a href="#Use-Case-3" class="headerlink" title="Use-Case #3"></a>Use-Case #3</h2><p>The last case is the easiest one. Our multiply function simply prints the result:</p><p>We have a simple function without output parameters. For this example I implemented the following multiplication function:</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">// Simple function that adds multiplies two numbers and prints the resultvoid multiply(const int a, const int b) &#123;  const int result = a * b;  std::cout << result << std::endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Then, we can simply call:</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">auto future = pool.submit(multiply, 2, 3);future.get();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>In this case, we know that as soon as the multiplication is done it will be printed. If we care when this is done, we can wait for it calling future.get().</p><p>Checkout the <a href="https://github.com/mtrebi/thread-pool/blob/master/src/main.cpp">main</a> program for a complete example.</p><h1 id="Future-work"><a href="#Future-work" class="headerlink" title="Future work"></a>Future work</h1><ul><li>Make it more reliable and safer (exceptions)</li><li>Find a better way to use it with member functions (thanks to @rajenk)</li><li>Run benchmarks and improve performance if needed<ul><li>Evaluate performance and impact of std::function in the heap and try alternatives if necessary. (thanks to @JensMunkHansen) </li></ul></li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="http://www.bogotobogo.com/cplusplus/multithreaded.php">MULTI-THREADED PROGRAMMING TERMINOLOGY - 2017</a>: Fast analysis of how a multi-thread system works</p></li><li><p><a href="https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">Universal References in C++11—Scott Meyers</a>: Universal references in C++11 by Scott Meyers</p></li><li><p><a href="http://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c/">Perfect forwarding and universal references in C++</a>: Article about how and when to use perfect forwarding and universal references</p></li><li><p><a href="http://www.cplusplus.com/reference/">C++ documentation</a>: Thread, conditional variables, mutex and many others…</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> article </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++2.0新特性_语言篇_1</title>
      <link href="2020/04/25/C++2.0%E6%96%B0%E7%89%B9%E6%80%A7_%E8%AF%AD%E8%A8%80%E7%AF%87_1/"/>
      <url>2020/04/25/C++2.0%E6%96%B0%E7%89%B9%E6%80%A7_%E8%AF%AD%E8%A8%80%E7%AF%87_1/</url>
      
        <content type="html"><![CDATA[<p>Part1~part12 from 侯捷老师C++系列<br><span id="more"></span></p><h2 id="Part-1-演进、环境与资源"><a href="#Part-1-演进、环境与资源" class="headerlink" title="Part 1 演进、环境与资源"></a>Part 1 演进、环境与资源</h2><p>C++2.0个人笔记（侯杰课程）</p><h3 id="演进"><a href="#演进" class="headerlink" title="演进"></a>演进</h3><p>C++1.0<br>C++2.0</p><h3 id="环境（C-2-0）"><a href="#环境（C-2-0）" class="headerlink" title="环境（C++2.0）"></a>环境（C++2.0）</h3><p>C++11<br>C++14</p><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><h4 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h4><p>Dev-C<br>KDevelop<br>Clion<br>VS</p><h4 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h4><p>G++<br>MinGW</p><h2 id="Part2-Variadic-Templates"><a href="#Part2-Variadic-Templates" class="headerlink" title="Part2 Variadic Templates"></a>Part2 Variadic Templates</h2><p>数量不定的模板参数</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">/*! * Created by william on 4/25/21. */#include <bits/stdc++.h>using namespace std;#include <iostream>void print()&#123;&#125;template <typename T,typename... Types>void print(const T& firstArg, const Types&... args)&#123;    cout<<firstArg<<endl;    print(args...);&#125;;int main()&#123;    print(7.5,"hello",bitset<16>(377),42);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>7.5hello000000010111100142</code></p><p>递归实现打印任意参数，任意数量的参数。</p><p>获取参数个数：Inside variadic templates, sizeoof…(args)yields the number of arguments</p><h2 id="Part-3-Spaces-in-Template-Expression、nullptr-and-std—nullptr-t、Automatic-Type-Deduc"><a href="#Part-3-Spaces-in-Template-Expression、nullptr-and-std—nullptr-t、Automatic-Type-Deduc" class="headerlink" title="Part 3. Spaces in Template Expression、nullptr and std—nullptr_t、Automatic Type Deduc"></a>Part 3. Spaces in Template Expression、nullptr and std—nullptr_t、Automatic Type Deduc</h2><h3 id="1-Spaces-in-Template-Expressions"><a href="#1-Spaces-in-Template-Expressions" class="headerlink" title="1.Spaces in Template Expressions"></a>1.Spaces in Template Expressions</h3><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">vector<list<int> >;  // OK in each C++ versionverctor<list<int>>;  // OK since C++11<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-nullptr-and-std-nullptr-t"><a href="#2-nullptr-and-std-nullptr-t" class="headerlink" title="2.nullptr and std::nullptr_t"></a>2.nullptr and std::nullptr_t</h3><p>C++11 lets you <code>use nullptr instead 0 or NULL</code> to specify <code>a pointer refers to no value</code>(which differs from having an undifined value). This new feature especially helps to <code>aviod mistakes that occurred when a null pointer was interpreted as an integral value</code>. For example:</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">void f(int);void f(void*);f(0);       // calls f(int)f(NULL);    // calls f(int) if NULL is 0, ambiguous  otherwisef(nullptr); // calls f(void*)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>nullptr is a new keyword. <u>It automatically converts into each pointer</u> type but not to any integral type. It has type std::nullptr_t, defined in <cstddef> (see Section 5.8.1,page 161), so you can now even overload operations for ths case that a null pointer is passed. Note that std::nullptr_t <u>counts as a fundamental data type</u> (see Section 5.4.2, page 127).</p><h3 id="3-Automatic-Type-Deduction-with-auto"><a href="#3-Automatic-Type-Deduction-with-auto" class="headerlink" title="3.Automatic Type Deduction with auto"></a>3.Automatic Type Deduction with auto</h3><p>With C++11, you can <u>declare a variable or an object without specifying its specific type</u> by using auto. For example:</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">auto i = 42; // i has type intdouble f();anto d = f()    // d has type double<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Using auto is <u>especially useful where the type is a pretty long and/or complicated expression</u>. For example:</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">vector<string> v;auto pos = v.begin();   // pos has type vector<string>::iteratorauto I = [](int x)->bool&#123;   // I has the type of a lambda    // ...                  // taking an int and return a bool&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Part-4-Uniform-Initialization"><a href="#Part-4-Uniform-Initialization" class="headerlink" title="Part 4 Uniform Initialization"></a>Part 4 Uniform Initialization</h2><p>统一初始化</p><p>Before C++11, programmers, especially novices, could easily become confused by the question of how to initialize a variable or an object.<br><u>Initialization could happen with parentheses, braces, and/or assignment operator</u>.</p><p>(在C ++ 11之前，程序员，尤其是新手，很容易对如何初始化变量或对象的问题感到困惑。 初始化可以使用括号 “()” ，花括号 “{}” 和/或赋值运算符 “=” 进行。)</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">Rect r1 = &#123;3, 7, 20, 25, &area, &print&#125;;Rect r2 = (3, 7, 20, 25);int ia[6] = &#123;27, 210, 12, 47, 109, 83&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>For this reason, C++11 introduced the concept of uniform initialization, which means that for any initialization, you can use one common syntax, This syntax use braces, so the following is possible now:</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">int values[] &#123;1, 2, 3&#125;;vector<int> ``v``&#123;2, 3, 5, 7, 11, 13, 17&#125;;vector<string> cities &#123;``"Berlin"``, ``"New York"``&#125;;complex<double> c&#123;4.0, 3.0&#125;;  ``//` `相当于 c(4.0, 3.0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>编译器看到 {t1, t2, …, tn} 时便会做出一个 initializer_list<T>,它关联至一个 array<T, n>。此时有会出现两种可能：</p><ul><li><p>调用函数（例如：构造函数）时该 array 内的元素可被逐一传给函数；</p></li><li><p>但若函数参数是个 initializer_list<T>， 调用者就不能给予数个 T 参数然后以为他们会被自动转换为一个 initializer_list<T> ”整包“传入。</p></li></ul><p>这形成一个 initializer_list<string>， 背后有个 array<string, 2>。调用 vector<string> ctors 时编译器找到了一个 vector<string> ctor 接受 initializer_list<T>，于是形成的initializer_list<string> 整包传入，不再进行分解。所有容器皆有函数参数类型为 initializer_list<T> 的 cvtor。</p><h2 id="Part-5-Initializer-list（上）"><a href="#Part-5-Initializer-list（上）" class="headerlink" title="Part 5 Initializer_list（上）"></a>Part 5 Initializer_list（上）</h2><p>初始化程序列表会强制进行所谓的值初始化，这意味着即使基本数据类型的局部变量（通常具有未定义的初始值）也将被初始化为零（如果为指针，则为nullpre）。</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">void func()&#123;  ``int i;   ``//` `i has undefined value  ``int j&#123;&#125;;  ``//` `j is initialized by 0   ``int *p;   ``//` `p has undefined value  ``int *q&#123;&#125;;  ``//` `q is initialized by nullptr&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，请注意，使用大括号不可能缩小初始化范围（这些初始化会降低精度或修改提供的值）。例如：</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">int x1(5.3);    // OK, but OUCH: x1 becomes 5int x2 = 5.3;   // OK, but OUCH: x3 becomes 5int x3&#123;5.0&#125;;    // ERROR: narrowingint x4 = &#123;5.3&#125;;`// ERROR: narrowingchar c1&#123;7&#125;;     // OK: even 7 is an int, this is not narrowingchar c2&#123;9999&#125;;  // ERROR: narrowing (if 9999 doesn't fit into a char)std::vector<int> v1 &#123;1, 2, 4, 5&#125;;       // OKstd::vector<int> v2 &#123;1, 2.3, 4, 5.6&#125;;   // ERROR: narrowing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Part-6-Initializer-list（下）"><a href="#Part-6-Initializer-list（下）" class="headerlink" title="Part 6 Initializer_list（下）"></a>Part 6 Initializer_list（下）</h2><h3 id="initializer-list-lt-gt"><a href="#initializer-list-lt-gt" class="headerlink" title="initializer_list&lt;&gt;"></a>initializer_list&lt;&gt;</h3><p>支持用户定义类型的初始化列表的概念。C++提供类模板std::initializer_list&lt;&gt;。它可以用于支持通过值列表进行初始化，也可以用于你只想处理值列表的任何其他地方。例如：</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">void print(std::initializer_list<int> vals)&#123;    for (auto p = vals.begin(); p!=vals.end(); ++p)    &#123;        std::cout << *p << "\n";    &#125;&#125;print(&#123;12, 3, 5, 7&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当既有特定数量的参数又有初始化器列表的构造函数时，首选带有初始化器列表的版本。</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">class P&#123;public:    P(int a, int b)    &#123;        cout << "P(int a, int b), a=" << a << ", b=" << b << endl;    &#125;    P(initializer_list<int> initlist)    &#123;        cout << "P(initializer_list<int> initlist), values=";        for (const auto &i : initlist)        &#123;            cout << i << ' ';        &#125;        cout << endl;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">P p(77, 5);P q&#123;77, 5&#125;;P r&#123;77, 5, 42&#125;;P s=&#123;77, 5&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">P(int a, int b), a=77, b=5P(initializer_list<int> initlist), values=77 5P(initializer_list<int> initlist), values=77 5 42P(initializer_list<int> initlist), values=77 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果没有用于初始化列表的构造函数，则将采用两个整数的构造函数来初始化q和s，而r的初始化将无效。</p><h2 id="Part-7-Explicit-for-ctors-taking-more-than-one-argument"><a href="#Part-7-Explicit-for-ctors-taking-more-than-one-argument" class="headerlink" title="Part 7 Explicit  for ctors taking more than one argument"></a>Part 7 Explicit  for ctors taking more than one argument</h2><p>概念：explicit用来针对构造函数接受一个以上实参。不允许进行隐式的调用构造函数。</p><p>所以加了explicit 关键字后，如果类没有以initializer_list为参数的构造函数，则不会将initializer_list 类型的数据拆分调用其他构造函数。</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">struct Complex&#123;    int real, imag;    Complex(int re, int im = 0) : real(re), imag(im)    &#123;        cout << "re=" << re << "; im=" << im << endl;    &#125;    Complex operator+(const Complex &x)    &#123;        cout << "Complex operator+(const Complex &x)" << endl;        return Complex(real+x.real, imag+x.imag);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">class P&#123;public:    explicit P(int a, int b, int c)    &#123;        cout << "explicit P(int a, int b, int c)" << endl;    &#125;&#125;;void func(const P &obj)&#123;    cout << "void func(class P &obj)" << endl;&#125;int main()&#123;    func(&#123;47, 11, 3&#125;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Part-8-range-based-for-statement"><a href="#Part-8-range-based-for-statement" class="headerlink" title="Part 8 range-based for statement"></a>Part 8 range-based for statement</h2><p>范式</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">for (decl/* 声明 */ : coll /* 容器 */)&#123;    // ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">for (int i : &#123;2, 4, 6, 8, 10&#125; /* initializer_list<int> */)&#123;    cout << i << endl;&#125;vector <double> vec&#123;2, 4, 6&#125;;for (auto ele : vec)&#123;    cout << elem << endl;&#125;for (auto &elem : vec)&#123;    elem *= 3;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：<code>auto &amp;elem</code> 的使用情况</p><ul><li>当需要修改容器内数据时；</li><li>非基础数据类型时， &amp; 避免拷贝构造，更为高效（不需要修改原数据时: const auto &amp;）</li></ul><h3 id="for-explicit"><a href="#for-explicit" class="headerlink" title="for + explicit"></a>for + explicit</h3><p>当在for循环中以声明的形式初始化时，不可能进行显式类型转换，因此，下面的代码不能编译。</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">class C&#123;public:    explicit C(const string &s) // explicit(!) type conversion from strings    &#123; &#125;    // ...&#125;;int main()&#123;    vector<string> vs;    for (const C &elem : vs)    &#123;        // ...    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">error: invalid initialization of reference of type 'const C&' from expression of type 'std::__cxx11::basic_string<char>'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="part-9-default-amp-amp-delete"><a href="#part-9-default-amp-amp-delete" class="headerlink" title="part 9 =default &amp;&amp; =delete"></a>part 9 =default &amp;&amp; =delete</h2><p>如果自定义了一个构造函数，那么编译器不会再生成任何一个default ctor。</p><p>如果强加上 <code>=default</code>,就可以重新获得并使用 default ctor。</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">class Zoo&#123;public:    Zoo(int i1, int i2) : d1(i1), d2(i2) &#123; &#125;    Zoo(const Zoo&) = delete ;//拷贝构造函数    Zoo(Zoo&&) = default;//右值 move    Zoo& operator=(const Zoo&) = default;//赋值    Zoo& operator=(Zoo&&) = delete;    virtual ~Zoo() &#123; &#125;private:    int d1;    int d2;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="F:\william\2021\C++2.0\default&amp;&amp;delete_pic1.png" alt=""></p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">class Foo&#123;public:    Foo(int i) : _i(i) &#123;&#125;    Foo() = default;    Foo(const Foo &x) : _i(x._i) &#123;&#125;     // Foo(const Foo&) = default;  //  error: ‘Foo::Foo(const Foo&)’ cannot be overloaded   // Foo(const Foo&) = delete;    // error: ‘Foo::Foo(const Foo&)’ cannot be overloaded    Foo& operator=(const Foo &x) &#123;_i = x._i; return *this;&#125;    // Foo& operator=(const Foo &x) = default;  // error: ‘Foo& Foo::operator=(const Foo&)’ cannot be overloaded    // Foo& operator=(const Foo &x) = delete;   // error: ‘Foo& Foo::operator=(const Foo&)’ cannot be overloaded    // void func1() = default;  // error: ‘void Foo::func1()’ cannot be defaulted    void func2() = delete;    // ~Foo() = delete;  // 编译通过。这可能会造成使用 Foo object 时出错 =>   error: use of deleted function ‘Foo::~Foo()’    ~Foo() = default;private:    int _i;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>需要自己写Big-Three的情况：</p><p>一个类包含pointer member，就可以断定需要写；没有指针成员，则使用默认一套成员即可。</p><p>Complex：没有指针，没有operator=(const complex&lt;…&gt;&amp;)</p><p>string：有Big-Five</p></li></ul><h3 id="No-COpy-and-Private-Copy"><a href="#No-COpy-and-Private-Copy" class="headerlink" title="No-COpy and Private-Copy"></a>No-COpy and Private-Copy</h3><p><img src="F:\william\2021\C++2.0\9.2No-COpy and Private-Copy.png" alt=""></p><h3 id="bost-nonocopyable"><a href="#bost-nonocopyable" class="headerlink" title="bost::nonocopyable"></a>bost::nonocopyable</h3><h2 id="Part-10-Alias-Template-template-typdef"><a href="#Part-10-Alias-Template-template-typdef" class="headerlink" title="Part 10 Alias Template (template typdef)"></a>Part 10 Alias Template (template typdef)</h2><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">template <typename T>using Vec = std::vector<T, MyAlloc<T>>;  // standard vector using own allocatorVec<int> coll;// [等价于]  <==> std::vector<int, MyAlloc<int>> coll;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="难道-using-只是为了少打几个字母？"><a href="#难道-using-只是为了少打几个字母？" class="headerlink" title="难道 using 只是为了少打几个字母？"></a>难道 using 只是为了少打几个字母？</h3><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">template <typename Container, typename T>void func(Container cnt, T elem)&#123;    Container<T> c;    //  ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Part-11-template-template-parameter"><a href="#Part-11-template-template-parameter" class="headerlink" title="Part 11 template template parameter"></a>Part 11 template template parameter</h2><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">template <typename T, template <typename> class Container >  // 注意这里！！class Func&#123;private:    Container<T> c &#123; T() &#125;;public:    Func()    &#123;  &#125;    // ..&#125;;//--------func(vector<string>());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">error: type/value mismatch at argument 2 in template parameter list for 'template<class T, template<class> class Container> class Func'expected a template of type 'template<class> class Container', got 'template<class _Tp, class _Alloc> class std::vector'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>根据编译错误提示，可知问题在 std::vector，与单参数<T>期望不否。<br>可是 vector 第二个模板参数有指定默认值，那为什么还会报错呢？是因为，当作为模板模板参数进行传递时，编译器无法再完成模板模板参数默认值的推导，即 <code>typename _Alloc = std::allocator&lt;_Tp&gt;</code> 编译器无法推导得出，需要手动指定。</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">#include <iostream>#include <vector>#include <list>using namespace std;const int SIZE = 100;template <typename T,        template <typename T>        class Container>class XCls&#123;private:    Container<T> c;public:    XCls()    &#123;        for(long i=0; i<SIZE; ++i)            c.insert(c.end(), T());        //output_static_data(T());        Container<T> c1(c);        Container<T> c2(std::move(c));        c1.swap(c2);    &#125; &#125;;//--------------template<typename T>using Vec = vector<T, allocator<T>>;int main() &#123;    //不得在function body之内声明    XCls<string, Vec> c1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Part-12-Type-Alias-noexcept-override-final"><a href="#Part-12-Type-Alias-noexcept-override-final" class="headerlink" title="Part 12 Type Alias noexcept override final"></a>Part 12 Type Alias noexcept override final</h2><h3 id="Type-Alias"><a href="#Type-Alias" class="headerlink" title="Type Alias"></a>Type Alias</h3><p>类型别名声明和typedef声明之间没有区别。 该声明可能出现在块作用域，类作用域或名称空间作用域中。</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">// type alias, idential to// tyodef void (*func)(int, int);// <<==>>using func = void(*)(int, int);// the name 'func' now denote a pointer to function:void example(int, int)&#123; &#125;func fn = example;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">// type alias can introduce a member typedef name// (类型别名可以引入成员typedef名称)template <typename T>struct Container&#123;    using value_type = T; // <==> typedef T value_type;&#125;;// type alias can introduce a member typedef name// (类型别名可以引入成员typedef名称)template <typename T>struct Container&#123;    using value_type = T; // <==> typedef T value_type;&#125;;//-----template <typename Cntr>void fn2(const Cntr &c)&#123;    typename Cntr::value_type n;  // 注意这里！！&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">类型别名，用于隐藏模板参数template <class CharT>using mystring = std::basic_string<CharT, std::char_traits<CharT>>;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如, <string> 和 <string_fwd.h> 都有以下 typdef :<br><code>typedef basic_string&lt;char&gt; string;</code></p><h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><ol><li><p>名称空间使用指令和名称空间成员使用声明;</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">using namespace std;using std::count;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>类成员的使用声明</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++"><stl_bvector.h>protected:    using _Base::M_allocate;    using _Base::M_deallocate;    using _Base::_S_nword;    using _Base::M_get_Bit_allocator;<std_list.h>    using _Base::_M_impl;    using _Base::_M_put_node;    using _Base::_M_get_node;    using _Base::_M_get_Tp_allocator;    using _Base::_M_get_Node_allocator;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>type alias and alias template declaration(Since C++11)</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">using func = void(*)(int,int);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h3><p>你需要通知C ++（特别是std :: vector）你的move构造函数和析构函数不会抛出。 然后，当向量增长（扩容）时，将调用move构造函数。 如果构造函数不是noexcept，则std :: vector不能使用它，因为那样就不能确保标准要求的保护性保证。</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">class MyString&#123;private:    char *_data;    size_t _len;    // ...public:    // move construct    MyString(MyString &&str) noexcept         : _data(str._data), _len(str._len)    &#123; &#125;    // move assignment    MyString &operator=(MyString &&str) noexcept    &#123;                // ...        return *this;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>在成员函数声明或定义中，<code>override</code>确保该函数为虚函数并覆盖某个基类中的虚函数。若此非真则程序生成编译错误。</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">struct Base&#123;    virtual void vfunc(float)    &#123; &#125;&#125;;struct Derived1 : public Base&#123;    // 当打算覆盖基类函数时意外地创建了一个新的虚函数。这是一个普遍的问题，尤其是当用户去修改基类时    virtual void vfunc(int)  // error: ‘virtual void Derived::vfunc(int)’ marked ‘override’, but does not override    &#123; &#125; &#125;;struct Derived : public Base&#123;    // 覆盖意味着编译器将检查基类，以查看是否存在具有此确切签名的虚函数。 如果没有，编译器将指示错误。    virtual void vfunc(int) override  // error: ‘virtual void Derived::vfunc(int)’ marked ‘override’, but does not override    &#123; &#125;      virtual void vfunc(float) override  // OK    &#123; &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>当在虚函数声明或定义中使用时，<code>final</code>确保函数为虚并指定其不可被派生类覆盖。否则生成编译时错误。</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">struct Base final&#123; &#125;;struct Derived : Base  // error: cannot derive from ‘final’ base ‘Base’ in derived type ‘Derived’&#123; &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当在类定义中使用时，<code>final</code>指定此类不可在另一类的定义中的基类说明符列表中出现（换言之，不能派生于它）。否则生成编译时错误。</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">struct Base&#123;    virtual void f() final;  // error: virtual function ‘virtual void Derived::f()’void f();&#125;;struct Derived : public Base&#123;    void f();  // error: virtual function ‘virtual void Derived::f()’ void f();&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Part-13-Lambdas"><a href="#Part-13-Lambdas" class="headerlink" title="Part 13 Lambdas"></a>Part 13 Lambdas</h3><p>C ++引入了lambda，允许定义内联功能，这些功能可用作参数或本地对象。 lambdas更改了C ++标准库的使用方式。</p><p>Lambda是功能的定义,可以在内部语句和表达式中定义。因此，你可以将lambda用作内联函数。 最小lambda函数没有参数，并且简单地完成一些操作。</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">[] &#123;     std::cout << "hello lambda" << srd::endl;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a href="params list">capture list</a> mutable<code>opt</code> throwSpec<code>opt</code> -&gt;retType<code>opt</code> {function body}</p><ul><li>capture list：捕获外部变量列表</li><li>params list：形参列表</li><li>mutable指示符：用来说明是否可以修改捕获的变量</li><li>exception：异常说明</li><li>return type：返回类型</li><li>function body：函数体</li></ul><p>捕获以访问lambda内部的非静态外部对象。 可以使用诸如std :: cout之类的静态对象。您可以指定捕获以访问未作为参数传递的外部范围数据。</p><div class="table-container"><table><thead><tr><th>[ ]</th><th>不捕获任何外部变量</th></tr></thead><tbody><tr><td>[变量名, …]</td><td>默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&amp;说明符）</td></tr><tr><td>[this]</td><td>以值的形式捕获this指针</td></tr><tr><td>[=]</td><td>以值的形式捕获所有外部变量</td></tr><tr><td>[&amp;]</td><td>以引用形式捕获所有外部变量</td></tr><tr><td>[=, &amp;x]</td><td>变量x以引用形式捕获，其余变量以传值形式捕获</td></tr><tr><td>[&amp;, x]</td><td>变量x以值的形式捕获，其余变量以引用形式捕获</td></tr></tbody></table></div><h3 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h3><p>对象按值传递，但是在lambda定义的函数对象内部，你可以对传递的值进行写访问。</p><h3 id="throwSpec"><a href="#throwSpec" class="headerlink" title="throwSpec"></a>throwSpec</h3><p>提供异常说明</p><h3 id="retType"><a href="#retType" class="headerlink" title="retType"></a>retType</h3><p>在没有对返回类型进行任何特定定义的情况下，将从返回值中推导出来。</p><p><strong>匿名函数对象</strong></p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">// objects are passed by value, but inside the function object defined by the lambda, // you have write access to the passed value.void func1()&#123;    int id = 0;    auto f = [id] () mutable &#123;        cout << id << " ";        id++;    &#125;;    id = 42;    f();    f();    f();    cout << id << endl;  // print : 0 1 2 42: &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">void func2()&#123;    int id = 0;    auto f = [&id] () &#123;        cout << "id: " << id << endl;        id++;    &#125;;    id = 42;    f();    f();    f();    cout << id << endl;  // print : 42 43 44 45&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">void func3()&#123;    int id = 0;    auto f = [id] () &#123;        cout << "id: " << id << endl;        id++;  // error: increment of read-only variable ‘id’    &#125;;    id = 42;    f();    f();    f();    cout << id << endl;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">void func4()&#123;    int id = 0;    auto f = [id]   () mutable &#123;        cout << "id: " << id << endl;        id++;        static int x = 5;  // 可以声明变量        int y = 6;         // 可以声明返回值        return id;    &#125;;    f();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们编写一个 lambda后， 编译器将该表达时翻译成一个未命名的未命名对象。再 lambda 表达时产生的类中含有一个重载的函数调用运算符。默认情况下 lambda 不能改变它捕获的变量。因此在默认情况下，由 lambda 产生的类当中的函数调用运算符是一个 const 成员函数。如果 lambda 被声明为 mutable， 则调用运算符就不是 const 的了。</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">int tobefound = 5;auto lambda1 = [tobefound] (int val) &#123;return val == tobefound;&#125;;class UnNameLocalFunction&#123;    int locaVal;public:       UnNameLocalFunction(int var) : locaVal(var)     &#123; &#125;    bool operator () (int val) const    &#123;        return val = locaVal;    &#125;&#125;;UnNameLocalFunction lambda2(tobefound);bool b1 = lambda1(5);bool b2 = lambda2(5);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Lambda的类型是一个匿名函数对象，对于每个Lambda表达式都是唯一的。 因此，要声明该类型的对象，您需要templates或auto。 如果需要该类型，则可以使用decltype(), 例如，需要将lambda作为散列函数传递，或者将排序或排序规则传递给关联的或无序的容器;</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">auto cmp = [] (const Person &p1, const Person &p2)                        &#123;                            return p1.lastname() < p2.lastname()                               || (p1.lastname() == p2.lastname()                                   && p1.firstname() < p2.lastname());                        &#125;;std::set<Person, decltype(cmp)> coll(cmp);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">//set实现template <class Key,          class Compare = less<Key>,          class Alloc = alloc>class set&#123;public:    // typedes:    ...    typedef Compare key_compare;    typedef Compare value_compare;private:    typedef rb_tree<key_type, value_type,                    identity<value_type>,                    key_compare, Alloc> rep_type;    rep_type t; // red-black tree representing setpublic:    ...    set() : t(Compare()) &#123;&#125;    explicit set(const Compare &comp) : t(comp) &#123;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（函数对象是一种非常强大的方法，可自定义标准模板库（STL）算法的行为，并且可以封装代码和数据（与普通函数不同）。 但是由于需要编写整个类，因此函数对象的定义不方便。 而且，它们没有在您试图使用它们的源代码中定义，并且非本地性使它们更难使用。 库已经尝试减轻一些冗长和非局部性的问题，但是由于语法变得复杂并且编译器错误不是很友好，因此没有提供太多帮助。 使用库中的函数对象的效率也较低，因为定义为数据成员的函数对象不是内联的。）</p><p>Lambda表达式解决了这些问题。 以下代码段显示了一个lambda表达式，该表达式在程序中用于从向量整数中删除变量x和y之间的整数。</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">#include <iostream>#include <vector>#include <algorithm>using namespace std;void func1()&#123;    vector<int> vi &#123;5, 28, 50, 83, 70, 590, 245, 59, 24&#125;;    int x = 30;    int y = 100;    vi.erase(remove_if(vi.begin(),                        vi.end(),                        [x, y](int n) &#123;return x<n && n<y;&#125;                        ),              vi.end()             );    for (auto i : vi)        cout << i << ' ';    cout << endl;&#125;void func2()&#123;    class LambdaFunctor    &#123;    public:        LambdaFunctor(int a, int b) : m_a(a), m_b(b)        &#123; &#125;        bool operator() (int n) const        &#123;            return m_a < n && n < m_b;        &#125;    private:        int m_a;        int m_b;    &#125;;    vector<int> vi &#123;5, 28, 50, 83, 70, 590, 245, 59, 24&#125;;    int x = 30;    int y = 100;    vi.erase(remove_if(vi.begin(),                        vi.end(),                        LambdaFunctor(x, y)),              vi.end()             );    for (auto i : vi)        cout << i << ' ';    cout << endl;&#125;int main()&#123;    func1();    func2();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">//打印结果5 28 590 245 245 28 590 245 24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/01/25/hello-world/"/>
      <url>2020/01/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post.<br><span id="more"></span><br>Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> article </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
