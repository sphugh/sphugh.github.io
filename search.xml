<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>轨道平顺性概念介绍</title>
      <link href="2021/05/20/%E5%B9%B3%E9%A1%BA%E6%80%A7%E7%BC%96%E7%A8%8B%E5%85%AC%E5%BC%8F/"/>
      <url>2021/05/20/%E5%B9%B3%E9%A1%BA%E6%80%A7%E7%BC%96%E7%A8%8B%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>文章介绍了轨道平顺性的基本概念并进行了编程实现<br><span id="more"></span></p><h2 id="轨距"><a href="#轨距" class="headerlink" title="轨距"></a>轨距</h2><p><img src="http://121.41.12.100:8080/%E9%AB%98%E9%93%81%E8%BD%A8%E9%81%93%E5%B9%B3%E9%A1%BA%E6%80%A7/%E8%BD%A8%E8%B7%9D.jpg" alt=""></p><p>轨道两侧AB点间的距离：</p><script type="math/tex; mode=display">A\left(x_{1}, y_{1}, z_{1}\right), \quad B\left(x_{2}, y_{2}, z_{2}\right)</script><script type="math/tex; mode=display">|A B|=\sqrt{\left(x_{1}-x_{2}\right)^{2}+\left(y_{1}-y_{2}\right)^{2}+\left(z_{1}-z_{2}\right)^{2}}</script><p>则两期轨距变化量为：</p><script type="math/tex; mode=display">\Delta|A B|=|A B|^{2}-|A B|^{1}</script><h2 id="水平（超高）"><a href="#水平（超高）" class="headerlink" title="水平（超高）"></a>水平（超高）</h2><p><img src="http://121.41.12.100:8080/%E9%AB%98%E9%93%81%E8%BD%A8%E9%81%93%E5%B9%B3%E9%A1%BA%E6%80%A7/%E6%B0%B4%E5%B9%B3%E8%B6%85%E9%AB%98.jpg" alt=""></p><p>轨道两侧AB点间的距离：</p><script type="math/tex; mode=display">A\left(x_{1}, y_{1}, z_{1}\right), \quad B\left(x_{2}, y_{2}, z_{2}\right)</script><script type="math/tex; mode=display">\Delta h=z_{2}-z_{1}</script><p>则两期轨距变化量（有方向）为：</p><script type="math/tex; mode=display">\Delta H=\Delta h^{2}-\Delta h^{1}</script><h2 id="高低"><a href="#高低" class="headerlink" title="高低"></a>高低</h2><p>高低是指钢轨的顶面垂直方向上高于或低于理论轨面的差值，反应了轨道线路的垂直方向的凹凸不平顺性。如上图所示，为高低的测量计算原理：</p><p><img src="http://121.41.12.100:8080/%E9%AB%98%E9%93%81%E8%BD%A8%E9%81%93%E5%B9%B3%E9%A1%BA%E6%80%A7/%E9%AB%98%E4%BD%8E10%E7%B1%B3.png" alt="" style="zoom:40%;" /></p><p>根据P<sub>1</sub> 到P<sub>17</sub> 各个测量点的坐标求解出对应的里程和高程，然后以里程为X 轴坐标，高程为Y 轴坐标，建立平面坐标系。通过P<sub>1</sub> 点和P<sub>17</sub> 点的坐标计算直线P<sub>1</sub> 与P<sub>17</sub> 的直线方程，然后将P<sub>9</sub> 点投影都直线上，得出投影失距s：</p><p>设P<sub>i</sub>，P<sub>i+8</sub>，P<sub>i+16</sub>坐标依次为：</p><script type="math/tex; mode=display">P_{i}\left(x_{i}, y_{i}, z_{i}\right)，P_{i+8}\left(x_{i+8}, y_{i+8}, z_{i+8}\right)，P_{i+16}\left(x_{i+16}, y_{i+16}, z_{i+16}\right)</script><p>则高低计算公式为：</p><script type="math/tex; mode=display">s=\left.\frac{\left(\left(\left(\mathrm{x}_{\mathrm{i}}-\mathrm{x}_{\mathrm{i}+16}\right) *\left(\mathrm{z}_{\mathrm{i}} *\left(\mathrm{x}_{\mathrm{i}+8}-\mathrm{x}_{\mathrm{i}+16}\right)-\mathrm{z}_{\mathrm{i}+16} *\left(\mathrm{x}_{\mathrm{i}+8}-\mathrm{x}_{\mathrm{i}}\right)\right)+\left(\mathrm{y}_{\mathrm{i}}-\mathrm{y}_{\mathrm{i}+16}\right) *\left(\mathrm{z}_{\mathrm{i}} *\left(\mathrm{y}_{\mathrm{i}+8}-\mathrm{y}_{\mathrm{i}+16}\right)-\mathrm{z}_{\mathrm{i}+16} *\left(\mathrm{y}_{\mathrm{i}+8}-\mathrm{y}_{\mathrm{i}}\right)\right.\right.\right.}{\left.\left(\left(\mathrm{x}_{\mathrm{i}}-\mathrm{x}_{\mathrm{i}+16}\right)^{2} +\left(\mathrm{y}_{\mathrm{i}}-\mathrm{y}_{\mathrm{i}+16}\right)^{2}\right)-\mathrm{z}_{\mathrm{i}+8}\right)}\right)</script><p>两期高低变化量为：</p><script type="math/tex; mode=display">\Delta s= s^{2}- s^{1}</script><h2 id="轨向"><a href="#轨向" class="headerlink" title="轨向"></a>轨向</h2><p><img src="http://121.41.12.100:8080/%E9%AB%98%E9%93%81%E8%BD%A8%E9%81%93%E5%B9%B3%E9%A1%BA%E6%80%A7/%E8%BD%A8%E5%90%91.jpg" alt=""></p><p>轨向（正矢）指的是轨道的中心轴线在水平面上的平顺度。</p><p>设P<sub>i</sub>，P<sub>i+8</sub>，P<sub>i+16</sub>坐标依次为：</p><script type="math/tex; mode=display">P_{i}\left(x_{i}, y_{i}, z_{i}\right)，P_{i+8}\left(x_{i+8}, y_{i+8}, z_{i+8}\right)，P_{i+16}\left(x_{i+16}, y_{i+16}, z_{i+16}\right)</script><p>则高低计算公式为：</p><script type="math/tex; mode=display">s=\frac{\left(\mathrm{y}_{\mathrm{i}+16}-\mathrm{y}_{\mathrm{i}}\right) * \mathrm{x}_{\mathrm{i}+8}+\left(\mathrm{x}_{\mathrm{i}}-\mathrm{x}_{\mathrm{i}+16}\right) * \mathrm{y}_{\mathrm{i}+8}+\mathrm{x}_{\mathrm{i}+16} * \mathrm{y}_{\mathrm{i}}-\mathrm{x}_{\mathrm{i}} * \mathrm{y}_{\mathrm{i}+16}}{\sqrt{\left(\mathrm{x}_{\mathrm{i}}-\mathrm{x}_{\mathrm{i}+16}\right)^{2} +\left(\mathrm{y}_{\mathrm{i}}-\mathrm{y}_{\mathrm{i}+16}\right)^{2} } }</script><p>两期轨向变化量：</p><script type="math/tex; mode=display">\Delta s= s^{2}- s^{1}</script><h2 id="三角坑（扭曲）"><a href="#三角坑（扭曲）" class="headerlink" title="三角坑（扭曲）"></a>三角坑（扭曲）</h2><p><img src="http://121.41.12.100:8080/%E9%AB%98%E9%93%81%E8%BD%A8%E9%81%93%E5%B9%B3%E9%A1%BA%E6%80%A7/%E4%B8%89%E8%A7%92%E5%9D%912.png" alt=""></p><p>根据《铁路线路维修规则》，以弦长3m为标准，选取四个测量点P<sub>1</sub>、 P<sub>2</sub>、P<sub>3</sub>、 P<sub>4</sub>如图 3-6 中所示，图上的情况为最不理想的情况。设他们各自的实测高<br>程分别为H<sub>1</sub>、 H<sub>2</sub>、H<sub>3</sub>、 H<sub>4</sub>，则轨道扭曲平顺性测量公式为：</p><script type="math/tex; mode=display">H=\left(H_{1}-H_{2}\right)-\left(H_{3}-H_{4}\right)</script><p>两期扭曲变化量：</p><script type="math/tex; mode=display">\Delta H= H^{2}- H^{1}</script>]]></content>
      
      
      
        <tags>
            
            <tag> article </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx源码概览</title>
      <link href="2021/04/15/Nginx%E4%B8%AD%E7%9A%84%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>2021/04/15/Nginx%E4%B8%AD%E7%9A%84%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>90分钟NGINX锁的使用</p><span id="more"></span><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>1、nginx应用场景：静态web服务、反向代理、正向代理、负载均衡；</p><p>2、nginx实现代理功能的基石：accept锁</p><p>3、nginx实现文件操作的基石：线程池+自旋锁+信号量+互斥锁+条件变量</p><h2 id="1、NGINX应用场景"><a href="#1、NGINX应用场景" class="headerlink" title="1、NGINX应用场景"></a>1、NGINX应用场景</h2><p>nginx.conf</p><p>worker_processes 线程数目和CPU核心对应；</p><ul><li><p>反向均衡</p><p>1、服务器处理能力不一致，分配不一样的权重</p><p>2、服务器能力一致，最小连接数（共享内存）</p><p>3、为在客户端断开重连后依然能连接到该服务采用IPhash</p></li><li><p>如何保存最小连接数</p></li><li><p>多进程监听一个端口8888（加锁（共享内存））</p></li><li><p>锁放在共享内存中，epoll_wait();listend</p></li><li><p>work进程如何拿锁？</p></li></ul><h2 id="2、accept锁"><a href="#2、accept锁" class="headerlink" title="2、accept锁"></a>2、accept锁</h2><p>1、互斥锁10ms</p><p>2、自旋锁-&gt;原子操作</p><ul><li>没有发生线程切换</li><li>连接数多的话，采用自旋锁</li><li>连接数少的话，避免CPU空转，</li></ul><p>3、读写锁</p><p>4、条件变量</p><p>5、cas锁</p><p>连接数少的情况下：</p><p>自旋锁空转CPU一定时间后，如果仍然没有拿到锁的话，通过信号量（NGX_HAVE_POSIX_SEM）让出CPU（sem_wait阻塞让出CPU）</p><pre class="line-numbers language-c++"><code class="language-c++">//信号量//多层级高性能缓存设计//sem_intit(set *sem,int pshared, unsingned int value); value = 0;case  pshared==0多线程case  pshared ==1 关联进程value //信号量资源数默认为0；sem_wait,se_timedwait,sem_trywait-lock a semaphore //讲上面的value减一<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>突然连接数变多的情况：</p><pre class="line-numbers language-c++"><code class="language-c++">sem_post - unlocak a semphorevalue++;ngx_shmtx_wakeup(ngx_shmtx_t *mtx)ngx_shmtx_unlock(ngx_shmtx_t *mtx)if(ngx_use_accept_mutex) 连接数多的情况调用unlock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、NGINX实现文件操作的基石"><a href="#3、NGINX实现文件操作的基石" class="headerlink" title="3、NGINX实现文件操作的基石"></a>3、NGINX实现文件操作的基石</h2><p>任务队列和完成队列，自旋锁，push pop操作简单</p><p>任务数少，任务数多的情况，线程池</p><p>信号量？？？不行，初始值是固定的，任务数不行，只能使用条件变量，信号量可以解决的问题条件变量（多线程）都可以处理， 除了多进程。</p><p>通过条件变量去管理线程池，任务数少，休眠，反之则唤醒；</p><h1 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h1><pre class="line-numbers language-c++"><code class="language-c++">int socket(int domain, int type, int protocol);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li><li>type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。</li><li>protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议（这个协议我将会单独开篇讨论！）。</li></ul><pre class="line-numbers language-c++"><code class="language-c++">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。</li><li>addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同.</li><li>addrlen：对应的是地址的长度。</li></ul><pre class="line-numbers language-c++"><code class="language-c++">int listen(int sockfd, int backlog);int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p></li><li><p>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</p></li></ul><pre class="line-numbers language-c++"><code class="language-c++">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p><p>注意：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p><h1 id="reactor模型"><a href="#reactor模型" class="headerlink" title="reactor模型"></a>reactor模型</h1><p>1、事件驱动</p><p>2、处理一个或多个并发传递到服务端的服务请求</p><p>3、对传入的请求进行解复用并同步分派给关联handler</p><p>非阻塞IO+IO多路复用</p><h1 id="libevent"><a href="#libevent" class="headerlink" title="libevent"></a>libevent</h1><p>优点：跨平台，IO转event，忽略函数返回值，三个事件</p><p>针对reactor的封装，将网络io处理 转化为 事件处理</p><p>event 事件， event_base事件管理器</p><p>注册（event add）+检测+分派(callback)</p><p>网络编程如何学习：闭源——顺藤摸瓜，顺瓜摸藤</p><p>//对于服务端有三种事件1、网络事件2、定时事件3、信号事件 kill -9 pid</p><p>//log 系统 写日志，文件写不进去了，调试fd可用，日志重定向出现异常，内核以信号方式通知应用程序，捕获这个信号， fd重定向后可以打开</p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/01/25/threadpool/"/>
      <url>2021/01/25/threadpool/</url>
      
        <content type="html"><![CDATA[<p>threadpool介绍</p><span id="more"></span><h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><p>&nbsp;<a href="https://github.com/mtrebi/thread-pool/blob/master/README.md#introduction">Introduction</a>  <br/><br>&nbsp;<a href="https://github.com/mtrebi/thread-pool/blob/master/README.md#build-instructions">Build instructions</a>  <br/><br>&nbsp;<a href="https://github.com/mtrebi/thread-pool/blob/master/README.md#thread-pool">Thread pool</a><br/><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/mtrebi/thread-pool/blob/master/README.md#queue">Queue</a><br/><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/mtrebi/thread-pool/blob/master/README.md#submit-function">Submit function</a>  <br/><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/mtrebi/thread-pool/blob/master/README.md#thread-worker">Thread worker</a>  <br/><br>&nbsp;<a href="https://github.com/mtrebi/thread-pool/blob/master/README.md#usage-example">Usage example</a>  <br/><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/mtrebi/thread-pool#use-case-1">Use case#1</a>  <br/><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/mtrebi/thread-pool#use-case-2">Use case#2</a>  <br/><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/mtrebi/thread-pool#use-case-3">Use case#3</a>  <br/><br>&nbsp;<a href="https://github.com/mtrebi/thread-pool/blob/master/README.md#future-work">Future work</a>  <br/><br>&nbsp;<a href="https://github.com/mtrebi/thread-pool/blob/master/README.md#references">References</a>  <br/> </p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction:"></a>Introduction:</h1><p>A <a href="https://en.wikipedia.org/wiki/Thread_pool">thread pool</a> is a technique that allows developers to exploit the concurrency of modern processors in an <strong>easy</strong> and <strong>efficient</strong> manner. It’s easy because you send “work” to the pool and somehow this work gets done without blocking the main thread. It’s efficient because threads are not initialized each time we want the work to be done. Threads are initialized once and remain inactive until some work has to be done. This way we minimize the overhead.</p><p>There are many more Thread pool implementations in C++, many of them are probably better (safer, faster…) than mine. However,I believe my implementation are <strong>very straightforward and easy to understand</strong>. </p><p><strong>Disclaimer: Please Do not use this project in a professional environment. It may contain bugs and/or not work as expected.</strong> I did this project to learn how C++11 Threads work and provide an easy way for other people to understand it too. </p><h1 id="Build-instructions"><a href="#Build-instructions" class="headerlink" title="Build instructions:"></a>Build instructions:</h1><p>This project has been developed using Netbeans and Linux but it should work on Windows, MAC OS and Linux. It can be easily build using CMake and different other generators. The following code can be used to generate the VS 2017 project files:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// VS 2017</span>cd <span class="token operator">&lt;</span>project<span class="token operator">-</span>folder<span class="token operator">></span>mkdir buildcd build<span class="token operator">/</span>cmake <span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token string">"Visual Studio 15 2017 Win64"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Then, from VS you can edit and execute the project. Make sure that <strong>main project is set up as the startup project</strong></p><p>If you are using Linux, you need to change the generator (use the default) and execute an extra operation to actually make it executable:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Linux</span>cd <span class="token operator">&lt;</span>project<span class="token operator">-</span>folder<span class="token operator">></span>mkdir buildcd build<span class="token operator">/</span>cmake <span class="token punctuation">.</span><span class="token punctuation">.</span>make<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Thread-pool"><a href="#Thread-pool" class="headerlink" title="Thread pool"></a>Thread pool</h1><p>The way that I understand things better is with images. So, let’s take a look at the image of thread pool given by Wikipedia:</p><p align="center">  <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/0c/Thread_pool.svg/580px-Thread_pool.svg.png"> </p><p>As you can see, we have three important elements here:</p><ul><li><em>Tasks Queue</em>. This is where the work that has to be done is stored.</li><li><em>Thread Pool</em>. This is set of threads (or workers) that continuously take work from the queue and do it.</li><li><em>Completed Tasks</em>. When the Thread has finished the work we return “something” to notify that the work has finished.</li></ul><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>We use a queue to store the work because it’s the more sensible data structure. We want the work to be <strong>started</strong> in the same order that we sent it. However, this queue is a little bit <strong>special</strong>. As I said in the previous section, threads are continuously (well, not really, but let’s assume that they are) querying the queue to ask for work. When there’s work available, threads take the work from the queue and do it. What would happen if two threads try to take the same work at the same time? Well, the program would crash.</p><p>To avoid these kinds of problems, I implemented a wrapper over the standard C++ Queue that uses mutex to restrict the concurrent access. Let’s see a small sample of the SafeQueue class:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_lock<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    m_queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>To enqueue the first thing we do is lock the mutex to make sure that no one else is accessing the resource. Then, we push the element to the queue. When the lock goes out of scopes it gets automatically released. Easy, huh? This way, we make the Queue thread-safe and thus we don’t have to worry many threads accessing and/or modifying it at the same “time”.</p><h2 id="Submit-function"><a href="#Submit-function" class="headerlink" title="Submit function"></a>Submit function</h2><p>The most important method of the thread pool is the one responsible of adding work to the queue. I called this method <strong>submit</strong>. It’s not difficult to understand how it works but its implementation can seem scary at first. Let’s think about <strong>what</strong> should do and after that we will worry about <strong>how</strong> to do it. What:</p><ul><li>Accept any function with any parameters.</li><li>Return “something” immediately to avoid blocking main thread. This returned object should <strong>eventually</strong> contain the result of the operation.</li></ul><p>Cool, let’s see <strong>how</strong> we can implement it.</p><h3 id="Submit-implementation"><a href="#Submit-implementation" class="headerlink" title="Submit implementation"></a>Submit implementation</h3><p>The complete submit functions looks like this:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Submit a function to be executed asynchronously by the pool</span>template<span class="token operator">&lt;</span>typename F<span class="token punctuation">,</span> typename<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">submit</span><span class="token punctuation">(</span>F<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token operator">-></span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>future<span class="token operator">&lt;</span><span class="token function">decltype</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Create a function with bounded parameters ready to execute</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>function<span class="token operator">&lt;</span><span class="token function">decltype</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> func <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>forward<span class="token operator">&lt;</span>F<span class="token operator">></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>forward<span class="token operator">&lt;</span>Args<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Encapsulate it into a shared ptr in order to be able to copy construct / assign </span>    <span class="token keyword">auto</span> task_ptr <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>make_shared<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>packaged_task<span class="token operator">&lt;</span><span class="token function">decltype</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Wrap packaged task into void function</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> wrapper_func <span class="token operator">=</span> <span class="token punctuation">[</span>task_ptr<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token punctuation">(</span><span class="token operator">*</span>task_ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Enqueue generic wrapper function</span>    m_queue<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>wrapperfunc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Wake up one thread if its waiting</span>    m_conditional_lock<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Return future from promise</span>    <span class="token keyword">return</span> task_ptr<span class="token operator">-></span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Nevertheless, we’re going to inspect line by line what’s going on in order to fully understand how it works. </p><h4 id="Variadic-template-function"><a href="#Variadic-template-function" class="headerlink" title="Variadic template function"></a>Variadic template function</h4><pre class="line-numbers language-c"><code class="language-c">template<span class="token operator">&lt;</span>typename F<span class="token punctuation">,</span> typename<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>This means that the next statement is templated. The first template parameter is called F (our function) and second one is a parameter pack. A parameter pack is a special template parameter that can accept zero or more template arguments. It is, in fact, a way to express a variable number of arguments in a template. A template with at least one parameter pack is called <strong>variadic template</strong></p><p>Summarizing, we are telling the compiler that our submit function is going to take one generic parameter of type F (our function) and a parameter pack Args (the parameters of the function F).</p><h4 id="Function-declaration"><a href="#Function-declaration" class="headerlink" title="Function declaration"></a>Function declaration</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">auto</span> <span class="token function">submit</span><span class="token punctuation">(</span>F<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token operator">-></span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>future<span class="token operator">&lt;</span><span class="token function">decltype</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>This may seem weird but, it’s not. A function, in fact, can be declared using two different syntaxes. The following is the most well known:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">return</span><span class="token operator">-</span>type <span class="token function">identifier</span> <span class="token punctuation">(</span> argument<span class="token operator">-</span>declarations<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>But, we can also declare the function like this:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">auto</span> <span class="token function">identifier</span> <span class="token punctuation">(</span> argument<span class="token operator">-</span>declarations<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token operator">-></span> return_type<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Why two syntaxes? Well, imagine that you have a function that has a return type that depends on the input parameters of the function. Using the first syntax you can’t declare that function without getting a compiler error since you  would be using a variable in the return type that has not been declared yet (because the return type declaration goes before the parameters type declaration). </p><p>Using the second syntax you can declare the function to have return type <strong>auto</strong> then, using the -&gt; you can declare the return type depending on the arguments of the functions that have been declared previously. </p><p>Now, let’s inspect the parameters of the submit function. When the type of a parameter is declared as <strong>T&amp;&amp;</strong> for some deducted type T that parameter is a <strong>universal reference</strong>. This term was coined by <a href="https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">Scott Meyers</a> because <strong>T&amp;&amp;</strong> can also mean r-value reference. However, in the context of type deduction, it means that it can be bound to both l-values and r-values, unlike l-value references that can only be bound to non-const objects (they bind only to modifiable lvalues) and r-value references (they bind only to rvalues).</p><p>The return type of the function is of type <strong>std::future<T></strong>. An std::future is a special type that provides a mechanism to access the result of asynchronous operations, in our case, the result of executing a specific function. This makes sense with what we said earlier.</p><p>Finally, the template type of std::future is <strong>decltype(f(args…))</strong>. Decltype is a special C++ keyword that inspects the declared type of an entity or the type and value category of an expression. In our case, we want to know the return type of the function <em>f</em>, so we give decltype our generic function <em>f</em> and the parameter pack <em>args</em>.</p><h4 id="Function-body"><a href="#Function-body" class="headerlink" title="Function body"></a>Function body</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Create a function with bounded parameters ready to execute</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>function<span class="token operator">&lt;</span><span class="token function">decltype</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> func <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>forward<span class="token operator">&lt;</span>F<span class="token operator">></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>forward<span class="token operator">&lt;</span>Args<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>There are many many things happening here. First of all, the <strong>std::bind(F, Args)</strong> is a function that creates a wrapper for F with the given Args. Caling this wrapper is the same as calling F with the Args that it has been bound. Here, we are simply calling bind with our generic function <em>f</em> and the parameter pack <em>args</em> but using another wrapper <strong>std::forward<T>(t)</strong> for each parameter. This second wrapper is needed to achieve perfect forwarding of universal references.<br>The result of this bind call is a <strong>std::function<T></strong>. The std::function<T> is a C++ object that encapsulates a function. It allows you to execute the function as if it were a normal function calling the operator() with the required parameters BUT, because it is an object, you can store it, copy it and move it around. The template type of any std::function is the signature of that function: std::function&lt; return-type (arguments)&gt;. In this case, we already know how to get the return type of this function using decltype. But, what about the arguments? Well, because we bound all arguments <em>args</em> to the function <em>f</em> we just have to add an empty pair of parenthesis that represents an empty list of arguments: <strong>decltype(f(args…))()</strong>.</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Encapsulate it into a shared ptr in order to be able to copy construct / assign </span><span class="token keyword">auto</span> task_ptr <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>make_shared<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>packaged_task<span class="token operator">&lt;</span><span class="token function">decltype</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>The next thing we do is we create a <strong>std::packaged_task<T>(t)</strong>.  A packaged_task is a wrapper around a function that can be executed asynchronously. It’s result is stored in a shared state inside an std::future<T> object. The templated type T of an std::packaged_task<T>(t) is the type of the function <em>t</em> that is wrapping. Because we said it before, the signature of the function <em>f</em> is <strong>decltype(f(args…))()</strong> that is the same type of the packaged_task. Then, we just wrap again this packaged task inside a <strong>std::shared_ptr</strong> using the initialize function <strong>std::make_shared</strong>.</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Wrap packaged task into void function</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> wrapperfunc <span class="token operator">=</span> <span class="token punctuation">[</span>task_ptr<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token punctuation">(</span><span class="token operator">*</span>task_ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Again, we create a std:.function, but, note that this time its template type is <strong>void()</strong>. Independently of the function <em>f</em> and its parameters <em>args</em> this <em>wrapperfunc</em> the return type will always be <strong>void</strong>. Since all functions <em>f</em> may have different return types, the only way to store them in a container (our Queue) is wrapping them with a generic void function. Here, we are just declaring this <em>wrapperfunc</em> to execute the actual task <em>taskptr</em> that will execute the bound function <em>func</em>.</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Enqueue generic wrapper function</span>m_queue<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>wrapperfunc<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>We enqueue this <em>wrapperfunc</em>. </p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Wake up one thread if its waiting</span>m_conditional_lock<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Before finishing, we wake up one thread in case it is waiting.</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Return future from promise</span><span class="token keyword">return</span> task_ptr<span class="token operator">-></span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>And finally, we return the future of the packaged_task. Because we are returning the future that is bound to the packaged_task <em>taskptr</em> that, at the same time, is bound with the function <em>func</em>, executing this <em>taskptr</em> will automatically update the future. Because we wrapped the execution of the <em>taskptr</em> with a generic wrapper function, is the execution of <em>wrapperfunc</em> that, in fact, updates the future. Aaaaand. since we enqueued this wrapper function, it will be executed by a thread after being dequeued calling the operator().</p><h2 id="Thread-worker"><a href="#Thread-worker" class="headerlink" title="Thread worker"></a>Thread worker</h2><p>Now that we understand how the submit method works, we’re going to focus on how the work gets done. Probably, the simplest implementation of a thread worker could be using polling:</p><pre><code> Loop    If Queue is not empty        Dequeue work        Do it</code></pre><p>This looks alright but it’s <strong>not very efficient</strong>. Do you see why? What would happen if there is no work in the Queue? The threads would keep looping and asking all the time: Is the queue empty? </p><p>The more sensible implementation is done by “sleeping” the threads until some work is added to the queue. As we saw before, as soon as we enqueue work, a signal <strong>notify_one()</strong> is sent. This allows us to implement a more efficient algorithm:</p><pre><code>Loop    If Queue is empty        Wait signal    Dequeue work    Do it</code></pre><p>This signal system is implemented in C++ with <strong>conditional variables</strong>. Conditional variables are always bound to a mutex, so I added a mutex to the thread pool class just to manage this. The final code of a worker looks like this: </p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> func<span class="token punctuation">;</span>    bool dequeued<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>m_pool<span class="token operator">-></span>m_shutdown<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_lock<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>m_pool<span class="token operator">-></span>m_conditional_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m_pool<span class="token operator">-></span>m_queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            m_pool<span class="token operator">-></span>m_conditional_lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        dequeued <span class="token operator">=</span> m_pool<span class="token operator">-></span>m_queue<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dequeued<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>              <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>The code is really easy to understand so I am not going to explain anything. The only thing to note here is that, <em>func</em> is our wrapper function declared as:</p><pre class="line-numbers language-c"><code class="language-c">std<span class="token punctuation">:</span><span class="token punctuation">:</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> wrapperfunc <span class="token operator">=</span> <span class="token punctuation">[</span>task_ptr<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token punctuation">(</span><span class="token operator">*</span>task_ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>So, executing this function will automatically update the future.</p><h1 id="Usage-example"><a href="#Usage-example" class="headerlink" title="Usage example"></a>Usage example</h1><p>Creating the thread pool is as easy as:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Create pool with 3 threads</span>ThreadPool <span class="token function">pool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Initialize pool</span>pool<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>When we want to shutdown the pool just call:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Shutdown the pool, releasing all threads</span>pool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Ff we want to send some work to the pool, after we have initialized it, we just have to call the submit function:</p><pre class="line-numbers language-c"><code class="language-c">pool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>work<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Depending on the type of work, I’ve distinguished different use-cases. Suppose that the work that we have to do is multiply two numbers. We can do it in many different ways. I’ve implemented the three most common ways to do it that I can imagine:</p><ul><li>Use-Case #1. Function returns the result</li><li>Use-Case #2. Function updates by ref parameter with the result</li><li>Use-Case #3. Function prints the result</li></ul><p><em>Note: This is just to show how the submit function works. Options are not exclusive</em></p><h2 id="Use-Case-1"><a href="#Use-Case-1" class="headerlink" title="Use-Case #1"></a>Use-Case #1</h2><p>The multiply function with a return looks like this:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Simple function that adds multiplies two numbers and returns the result</span><span class="token keyword">int</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token keyword">int</span> res <span class="token operator">=</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>  <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Then, the submit:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// The type of future is given by the return type of the function</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> future <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>multiply<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>We can also use the <strong>auto</strong> keyword for convenience:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">auto</span> future <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>multiply<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Nice, when the work is finished by the thread pool we know that the future will get updated and we can retrieve the result calling:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> result <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> result <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>The get() function of std::future<T> always return the type T of the future. <strong>This type will always be equal to the return type of the function passed to the submit method</strong>. In this case, int.</p><h2 id="Use-Case-2"><a href="#Use-Case-2" class="headerlink" title="Use-Case #2"></a>Use-Case #2</h2><p>The multiply function has a parameter passed by ref:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Simple function that adds multiplies two numbers and updates the out_res variable passed by ref</span><span class="token keyword">void</span>  <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> out_res<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    out_res <span class="token operator">=</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Now, we have to call the submit function with a subtle difference. Because we are using templates and type deduction (universal references), the parameter passed by ref needs to be called using <strong>std::ref(param)</strong> to make sure that we are passing it by ref and not by value.</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">auto</span> future <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>multiply<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">ref</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// result is 0</span>future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// result is 6</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> result <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>In this case, what’s the type of future? Well, as I said before, the return type will always be equal to the return type of the function passed to the submit method. Because this function is of type void, the future  is <strong>std::future<void></strong>. Calling future.get() returns void. That’s not very useful, but we still need to call .get() to make sure that the work has been done.</p><h2 id="Use-Case-3"><a href="#Use-Case-3" class="headerlink" title="Use-Case #3"></a>Use-Case #3</h2><p>The last case is the easiest one. Our multiply function simply prints the result:</p><p>We have a simple function without output parameters. For this example I implemented the following multiplication function:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Simple function that adds multiplies two numbers and prints the result</span><span class="token keyword">void</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token keyword">int</span> result <span class="token operator">=</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>  std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> result <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Then, we can simply call:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">auto</span> future <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>multiply<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>In this case, we know that as soon as the multiplication is done it will be printed. If we care when this is done, we can wait for it calling future.get().</p><p>Checkout the <a href="https://github.com/mtrebi/thread-pool/blob/master/src/main.cpp">main</a> program for a complete example.</p><h1 id="Future-work"><a href="#Future-work" class="headerlink" title="Future work"></a>Future work</h1><ul><li>Make it more reliable and safer (exceptions)</li><li>Find a better way to use it with member functions (thanks to @rajenk)</li><li>Run benchmarks and improve performance if needed</li><li>Evaluate performance and impact of std::function in the heap and try alternatives if necessary. (thanks to @JensMunkHansen) </li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="http://www.bogotobogo.com/cplusplus/multithreaded.php">MULTI-THREADED PROGRAMMING TERMINOLOGY - 2017</a>: Fast analysis of how a multi-thread system works</p></li><li><p><a href="https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">Universal References in C++11—Scott Meyers</a>: Universal references in C++11 by Scott Meyers</p></li><li><p><a href="http://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c/">Perfect forwarding and universal references in C++</a>: Article about how and when to use perfect forwarding and universal references</p></li><li><p><a href="http://www.cplusplus.com/reference/">C++ documentation</a>: Thread, conditional variables, mutex and many others…</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> article </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++2.0新特性_语言篇_1</title>
      <link href="2020/04/25/C++2.0%E6%96%B0%E7%89%B9%E6%80%A7_%E8%AF%AD%E8%A8%80%E7%AF%87_1/"/>
      <url>2020/04/25/C++2.0%E6%96%B0%E7%89%B9%E6%80%A7_%E8%AF%AD%E8%A8%80%E7%AF%87_1/</url>
      
        <content type="html"><![CDATA[<p>Part1~part12 from 侯捷老师C++系列</p><span id="more"></span><h2 id="Part-1-演进、环境与资源"><a href="#Part-1-演进、环境与资源" class="headerlink" title="Part 1 演进、环境与资源"></a>Part 1 演进、环境与资源</h2><p>C++2.0个人笔记（侯杰课程）</p><h3 id="演进"><a href="#演进" class="headerlink" title="演进"></a>演进</h3><p>C++1.0<br>C++2.0</p><h3 id="环境（C-2-0）"><a href="#环境（C-2-0）" class="headerlink" title="环境（C++2.0）"></a>环境（C++2.0）</h3><p>C++11<br>C++14</p><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><h4 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h4><p>Dev-C<br>KDevelop<br>Clion<br>VS</p><h4 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h4><p>G++<br>MinGW</p><h2 id="Part2-Variadic-Templates"><a href="#Part2-Variadic-Templates" class="headerlink" title="Part2 Variadic Templates"></a>Part2 Variadic Templates</h2><p>数量不定的模板参数</p><pre class="line-numbers language-c++"><code class="language-c++">/*! * Created by william on 4/25/21. */#include <bits/stdc++.h>using namespace std;#include <iostream>void print()&#123;&#125;template <typename T,typename... Types>void print(const T& firstArg, const Types&... args)&#123;    cout<<firstArg<<endl;    print(args...);&#125;;int main()&#123;    print(7.5,"hello",bitset<16>(377),42);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>7.5 hello 0000000101111001 42</code></p><p>递归实现打印任意参数，任意数量的参数。</p><p>获取参数个数：Inside variadic templates, sizeoof…(args)yields the number of arguments</p><h2 id="Part-3-Spaces-in-Template-Expression、nullptr-and-std–nullptr-t、Automatic-Type-Deduc"><a href="#Part-3-Spaces-in-Template-Expression、nullptr-and-std–nullptr-t、Automatic-Type-Deduc" class="headerlink" title="Part 3. Spaces in Template Expression、nullptr and std–nullptr_t、Automatic Type Deduc"></a>Part 3. Spaces in Template Expression、nullptr and std–nullptr_t、Automatic Type Deduc</h2><h3 id="1-Spaces-in-Template-Expressions"><a href="#1-Spaces-in-Template-Expressions" class="headerlink" title="1.Spaces in Template Expressions"></a>1.Spaces in Template Expressions</h3><pre class="line-numbers language-c++"><code class="language-c++">vector<list<int> >;  // OK in each C++ versionverctor<list<int>>;  // OK since C++11<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-nullptr-and-std-nullptr-t"><a href="#2-nullptr-and-std-nullptr-t" class="headerlink" title="2.nullptr and std::nullptr_t"></a>2.nullptr and std::nullptr_t</h3><p>C++11 lets you <code>use nullptr instead 0 or NULL</code> to specify <code>a pointer refers to no value</code>(which differs from having an undifined value). This new feature especially helps to <code>aviod mistakes that occurred when a null pointer was interpreted as an integral value</code>. For example:</p><pre class="line-numbers language-c++"><code class="language-c++">void f(int);void f(void*);f(0);       // calls f(int)f(NULL);    // calls f(int) if NULL is 0, ambiguous  otherwisef(nullptr); // calls f(void*)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>nullptr is a new keyword. <u>It automatically converts into each pointer</u> type but not to any integral type. It has type std::nullptr_t, defined in <cstddef> (see Section 5.8.1,page 161), so you can now even overload operations for ths case that a null pointer is passed. Note that std::nullptr_t <u>counts as a fundamental data type</u> (see Section 5.4.2, page 127).</p><h3 id="3-Automatic-Type-Deduction-with-auto"><a href="#3-Automatic-Type-Deduction-with-auto" class="headerlink" title="3.Automatic Type Deduction with auto"></a>3.Automatic Type Deduction with auto</h3><p>With C++11, you can <u>declare a variable or an object without specifying its specific type</u> by using auto. For example:</p><pre class="line-numbers language-c++"><code class="language-c++">auto i = 42; // i has type intdouble f();anto d = f()    // d has type double<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Using auto is <u>especially useful where the type is a pretty long and/or complicated expression</u>. For example:</p><pre class="line-numbers language-c++"><code class="language-c++">vector<string> v;auto pos = v.begin();   // pos has type vector<string>::iteratorauto I = [](int x)->bool&#123;   // I has the type of a lambda    // ...                  // taking an int and return a bool&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Part-4-Uniform-Initialization"><a href="#Part-4-Uniform-Initialization" class="headerlink" title="Part 4 Uniform Initialization"></a>Part 4 Uniform Initialization</h2><p>统一初始化</p><p>Before C++11, programmers, especially novices, could easily become confused by the question of how to initialize a variable or an object.<br><u>Initialization could happen with parentheses, braces, and/or assignment operator</u>.</p><p>(在C ++ 11之前，程序员，尤其是新手，很容易对如何初始化变量或对象的问题感到困惑。 初始化可以使用括号 “()” ，花括号 “{}” 和/或赋值运算符 “=” 进行。)</p><pre class="line-numbers language-c++"><code class="language-c++">Rect r1 = &#123;3, 7, 20, 25, &area, &print&#125;;Rect r2 = (3, 7, 20, 25);int ia[6] = &#123;27, 210, 12, 47, 109, 83&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>For this reason, C++11 introduced the concept of uniform initialization, which means that for any initialization, you can use one common syntax, This syntax use braces, so the following is possible now:</p><pre class="line-numbers language-c++"><code class="language-c++">int values[] &#123;1, 2, 3&#125;;vector<int> ``v``&#123;2, 3, 5, 7, 11, 13, 17&#125;;vector<string> cities &#123;``"Berlin"``, ``"New York"``&#125;;complex<double> c&#123;4.0, 3.0&#125;;  ``//` `相当于 c(4.0, 3.0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>编译器看到 {t1, t2, …, tn} 时便会做出一个 initializer_list<T>,它关联至一个 array&lt;T, n&gt;。此时有会出现两种可能：</p><ul><li><p>调用函数（例如：构造函数）时该 array 内的元素可被逐一传给函数；</p></li><li><p>但若函数参数是个 initializer_list<T>， 调用者就不能给予数个 T 参数然后以为他们会被自动转换为一个 initializer_list<T> ”整包“传入。</p></li></ul><p>这形成一个 initializer_list<string>， 背后有个 array&lt;string, 2&gt;。调用 vector<string> ctors 时编译器找到了一个 vector<string> ctor 接受 initializer_list<T>，于是形成的initializer_list<string> 整包传入，不再进行分解。所有容器皆有函数参数类型为 initializer_list<T> 的 cvtor。</p><h2 id="Part-5-Initializer-list（上）"><a href="#Part-5-Initializer-list（上）" class="headerlink" title="Part 5 Initializer_list（上）"></a>Part 5 Initializer_list（上）</h2><p>初始化程序列表会强制进行所谓的值初始化，这意味着即使基本数据类型的局部变量（通常具有未定义的初始值）也将被初始化为零（如果为指针，则为nullpre）。</p><pre class="line-numbers language-c++"><code class="language-c++">void func()&#123;  ``int i;   ``//` `i has undefined value  ``int j&#123;&#125;;  ``//` `j is initialized by 0     ``int *p;   ``//` `p has undefined value  ``int *q&#123;&#125;;  ``//` `q is initialized by nullptr&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，请注意，使用大括号不可能缩小初始化范围（这些初始化会降低精度或修改提供的值）。例如：</p><pre class="line-numbers language-c++"><code class="language-c++">int x1(5.3);    // OK, but OUCH: x1 becomes 5int x2 = 5.3;   // OK, but OUCH: x3 becomes 5int x3&#123;5.0&#125;;    // ERROR: narrowingint x4 = &#123;5.3&#125;;`// ERROR: narrowingchar c1&#123;7&#125;;     // OK: even 7 is an int, this is not narrowingchar c2&#123;9999&#125;;  // ERROR: narrowing (if 9999 doesn't fit into a char)std::vector<int> v1 &#123;1, 2, 4, 5&#125;;       // OKstd::vector<int> v2 &#123;1, 2.3, 4, 5.6&#125;;   // ERROR: narrowing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Part-6-Initializer-list（下）"><a href="#Part-6-Initializer-list（下）" class="headerlink" title="Part 6 Initializer_list（下）"></a>Part 6 Initializer_list（下）</h2><h3 id="initializer-list-lt-gt"><a href="#initializer-list-lt-gt" class="headerlink" title="initializer_list&lt;&gt;"></a>initializer_list&lt;&gt;</h3><p>支持用户定义类型的初始化列表的概念。C++提供类模板std::initializer_list&lt;&gt;。它可以用于支持通过值列表进行初始化，也可以用于你只想处理值列表的任何其他地方。例如：</p><pre class="line-numbers language-c++"><code class="language-c++">void print(std::initializer_list<int> vals)&#123;    for (auto p = vals.begin(); p!=vals.end(); ++p)    &#123;        std::cout << *p << "\n";    &#125;&#125;print(&#123;12, 3, 5, 7&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当既有特定数量的参数又有初始化器列表的构造函数时，首选带有初始化器列表的版本。</p><pre class="line-numbers language-c++"><code class="language-c++">class P&#123;public:    P(int a, int b)    &#123;        cout << "P(int a, int b), a=" << a << ", b=" << b << endl;    &#125;     P(initializer_list<int> initlist)    &#123;        cout << "P(initializer_list<int> initlist), values=";         for (const auto &i : initlist)        &#123;            cout << i << ' ';        &#125;        cout << endl;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">P p(77, 5);P q&#123;77, 5&#125;;P r&#123;77, 5, 42&#125;;P s=&#123;77, 5&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">P(int a, int b), a=77, b=5P(initializer_list<int> initlist), values=77 5P(initializer_list<int> initlist), values=77 5 42P(initializer_list<int> initlist), values=77 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果没有用于初始化列表的构造函数，则将采用两个整数的构造函数来初始化q和s，而r的初始化将无效。</p><h2 id="Part-7-Explicit-for-ctors-taking-more-than-one-argument"><a href="#Part-7-Explicit-for-ctors-taking-more-than-one-argument" class="headerlink" title="Part 7 Explicit  for ctors taking more than one argument"></a>Part 7 Explicit  for ctors taking more than one argument</h2><p>概念：explicit用来针对构造函数接受一个以上实参。不允许进行隐式的调用构造函数。</p><p>所以加了explicit 关键字后，如果类没有以initializer_list为参数的构造函数，则不会将initializer_list 类型的数据拆分调用其他构造函数。</p><pre class="line-numbers language-c++"><code class="language-c++">struct Complex&#123;    int real, imag;    Complex(int re, int im = 0) : real(re), imag(im)    &#123;        cout << "re=" << re << "; im=" << im << endl;    &#125;    Complex operator+(const Complex &x)    &#123;        cout << "Complex operator+(const Complex &x)" << endl;        return Complex(real+x.real, imag+x.imag);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">class P&#123;public:    explicit P(int a, int b, int c)    &#123;        cout << "explicit P(int a, int b, int c)" << endl;    &#125;&#125;;void func(const P &obj)&#123;    cout << "void func(class P &obj)" << endl;&#125;int main()&#123;    func(&#123;47, 11, 3&#125;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Part-8-range-based-for-statement"><a href="#Part-8-range-based-for-statement" class="headerlink" title="Part 8 range-based for statement"></a>Part 8 range-based for statement</h2><p>范式</p><pre class="line-numbers language-c++"><code class="language-c++">for (decl/* 声明 */ : coll /* 容器 */)&#123;    // ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">for (int i : &#123;2, 4, 6, 8, 10&#125; /* initializer_list<int> */)&#123;    cout << i << endl;&#125;vector <double> vec&#123;2, 4, 6&#125;;for (auto ele : vec)&#123;    cout << elem << endl;&#125;for (auto &elem : vec)&#123;    elem *= 3;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：<code>auto &amp;elem</code> 的使用情况</p><ul><li>当需要修改容器内数据时；</li><li>非基础数据类型时， &amp; 避免拷贝构造，更为高效（不需要修改原数据时: const auto &amp;）</li></ul><h3 id="for-explicit"><a href="#for-explicit" class="headerlink" title="for + explicit"></a>for + explicit</h3><p>当在for循环中以声明的形式初始化时，不可能进行显式类型转换，因此，下面的代码不能编译。</p><pre class="line-numbers language-c++"><code class="language-c++">class C&#123;public:    explicit C(const string &s) // explicit(!) type conversion from strings    &#123; &#125;    // ...&#125;;int main()&#123;    vector<string> vs;    for (const C &elem : vs)    &#123;        // ...    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">error: invalid initialization of reference of type 'const C&' from expression of type 'std::__cxx11::basic_string<char>'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="part-9-default-amp-amp-delete"><a href="#part-9-default-amp-amp-delete" class="headerlink" title="part 9 =default &amp;&amp; =delete"></a>part 9 =default &amp;&amp; =delete</h2><p>如果自定义了一个构造函数，那么编译器不会再生成任何一个default ctor。</p><p>如果强加上 <code>=default</code>,就可以重新获得并使用 default ctor。</p><pre class="line-numbers language-c++"><code class="language-c++">class Zoo&#123;public:    Zoo(int i1, int i2) : d1(i1), d2(i2) &#123; &#125;    Zoo(const Zoo&) = delete ;//拷贝构造函数    Zoo(Zoo&&) = default;//右值 move    Zoo& operator=(const Zoo&) = default;//赋值    Zoo& operator=(Zoo&&) = delete;    virtual ~Zoo() &#123; &#125;private:    int d1;    int d2;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="F:\william\2021\C++2.0\default&&delete_pic1.png"></p><pre class="line-numbers language-c++"><code class="language-c++">class Foo&#123;public:    Foo(int i) : _i(i) &#123;&#125;    Foo() = default;    Foo(const Foo &x) : _i(x._i) &#123;&#125;     // Foo(const Foo&) = default;  //  error: ‘Foo::Foo(const Foo&)’ cannot be overloaded   // Foo(const Foo&) = delete;    // error: ‘Foo::Foo(const Foo&)’ cannot be overloaded    Foo& operator=(const Foo &x) &#123;_i = x._i; return *this;&#125;    // Foo& operator=(const Foo &x) = default;  // error: ‘Foo& Foo::operator=(const Foo&)’ cannot be overloaded    // Foo& operator=(const Foo &x) = delete;   // error: ‘Foo& Foo::operator=(const Foo&)’ cannot be overloaded    // void func1() = default;  // error: ‘void Foo::func1()’ cannot be defaulted    void func2() = delete;    // ~Foo() = delete;  // 编译通过。这可能会造成使用 Foo object 时出错 =>   error: use of deleted function ‘Foo::~Foo()’    ~Foo() = default;private:    int _i;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>需要自己写Big-Three的情况：</p><p>一个类包含pointer member，就可以断定需要写；没有指针成员，则使用默认一套成员即可。</p><p>Complex：没有指针，没有operator=(const complex&lt;…&gt;&amp;)</p><p>string：有Big-Five</p></li></ul><h3 id="No-COpy-and-Private-Copy"><a href="#No-COpy-and-Private-Copy" class="headerlink" title="No-COpy and Private-Copy"></a>No-COpy and Private-Copy</h3><p>![](F:\william\2021\C++2.0\9.2No-COpy and Private-Copy.png)</p><h3 id="bost-nonocopyable"><a href="#bost-nonocopyable" class="headerlink" title="bost::nonocopyable"></a>bost::nonocopyable</h3><h2 id="Part-10-Alias-Template-template-typdef"><a href="#Part-10-Alias-Template-template-typdef" class="headerlink" title="Part 10 Alias Template (template typdef)"></a>Part 10 Alias Template (template typdef)</h2><pre class="line-numbers language-c++"><code class="language-c++">template <typename T>using Vec = std::vector<T, MyAlloc<T>>;  // standard vector using own allocatorVec<int> coll;// [等价于]  <==> std::vector<int, MyAlloc<int>> coll;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="难道-using-只是为了少打几个字母？"><a href="#难道-using-只是为了少打几个字母？" class="headerlink" title="难道 using 只是为了少打几个字母？"></a>难道 using 只是为了少打几个字母？</h3><pre class="line-numbers language-c++"><code class="language-c++">template <typename Container, typename T>void func(Container cnt, T elem)&#123;    Container<T> c;    //  ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Part-11-template-template-parameter"><a href="#Part-11-template-template-parameter" class="headerlink" title="Part 11 template template parameter"></a>Part 11 template template parameter</h2><pre class="line-numbers language-c++"><code class="language-c++">template <typename T, template <typename> class Container >  // 注意这里！！class Func&#123;private:    Container<T> c &#123; T() &#125;;public:    Func()    &#123;  &#125;    // ..&#125;;//--------func(vector<string>());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">error: type/value mismatch at argument 2 in template parameter list for 'template<class T, template<class> class Container> class Func'expected a template of type 'template<class> class Container', got 'template<class _Tp, class _Alloc> class std::vector'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>根据编译错误提示，可知问题在 std::vector，与单参数<T>期望不否。<br>可是 vector 第二个模板参数有指定默认值，那为什么还会报错呢？是因为，当作为模板模板参数进行传递时，编译器无法再完成模板模板参数默认值的推导，即 <code>typename _Alloc = std::allocator&lt;_Tp&gt;</code> 编译器无法推导得出，需要手动指定。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>#include <vector>#include <list>using namespace std;const int SIZE = 100;template <typename T,        template <typename T>        class Container>class XCls&#123;private:    Container<T> c;public:    XCls()    &#123;        for(long i=0; i<SIZE; ++i)            c.insert(c.end(), T());        //output_static_data(T());        Container<T> c1(c);        Container<T> c2(std::move(c));        c1.swap(c2);    &#125; &#125;;//--------------template<typename T>using Vec = vector<T, allocator<T>>;int main() &#123;    //不得在function body之内声明    XCls<string, Vec> c1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Part-12-Type-Alias-noexcept-override-final"><a href="#Part-12-Type-Alias-noexcept-override-final" class="headerlink" title="Part 12 Type Alias noexcept override final"></a>Part 12 Type Alias noexcept override final</h2><h3 id="Type-Alias"><a href="#Type-Alias" class="headerlink" title="Type Alias"></a>Type Alias</h3><p>类型别名声明和typedef声明之间没有区别。 该声明可能出现在块作用域，类作用域或名称空间作用域中。</p><pre class="line-numbers language-c++"><code class="language-c++">// type alias, idential to// tyodef void (*func)(int, int);// <<==>>using func = void(*)(int, int);// the name 'func' now denote a pointer to function:void example(int, int)&#123; &#125;func fn = example;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">// type alias can introduce a member typedef name// (类型别名可以引入成员typedef名称)template <typename T>struct Container&#123;    using value_type = T; // <==> typedef T value_type;&#125;;// type alias can introduce a member typedef name// (类型别名可以引入成员typedef名称)template <typename T>struct Container&#123;    using value_type = T; // <==> typedef T value_type;&#125;;//-----template <typename Cntr>void fn2(const Cntr &c)&#123;    typename Cntr::value_type n;  // 注意这里！！&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">类型别名，用于隐藏模板参数template <class CharT>using mystring = std::basic_string<CharT, std::char_traits<CharT>>;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如, <string> 和 &lt;string_fwd.h&gt; 都有以下 typdef :<br><code>typedef basic_string&lt;char&gt; string;</code></p><h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><ol><li><p>名称空间使用指令和名称空间成员使用声明;</p><pre class="line-numbers language-c++"><code class="language-c++">using namespace std;using std::count;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>类成员的使用声明</p><pre class="line-numbers language-c++"><code class="language-c++"><stl_bvector.h>protected:    using _Base::M_allocate;    using _Base::M_deallocate;    using _Base::_S_nword;    using _Base::M_get_Bit_allocator;<std_list.h>    using _Base::_M_impl;    using _Base::_M_put_node;    using _Base::_M_get_node;    using _Base::_M_get_Tp_allocator;    using _Base::_M_get_Node_allocator;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>type alias and alias template declaration(Since C++11)</p><pre class="line-numbers language-c++"><code class="language-c++">using func = void(*)(int,int);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h3><p>你需要通知C ++（特别是std :: vector）你的move构造函数和析构函数不会抛出。 然后，当向量增长（扩容）时，将调用move构造函数。 如果构造函数不是noexcept，则std :: vector不能使用它，因为那样就不能确保标准要求的保护性保证。</p><pre class="line-numbers language-c++"><code class="language-c++">class MyString&#123;private:    char *_data;    size_t _len;    // ...public:    // move construct    MyString(MyString &&str) noexcept         : _data(str._data), _len(str._len)    &#123; &#125;    // move assignment    MyString &operator=(MyString &&str) noexcept    &#123;                // ...        return *this;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>在成员函数声明或定义中，<code>override</code>确保该函数为虚函数并覆盖某个基类中的虚函数。若此非真则程序生成编译错误。</p><pre class="line-numbers language-c++"><code class="language-c++">struct Base&#123;    virtual void vfunc(float)    &#123; &#125;&#125;;struct Derived1 : public Base&#123;    // 当打算覆盖基类函数时意外地创建了一个新的虚函数。这是一个普遍的问题，尤其是当用户去修改基类时    virtual void vfunc(int)  // error: ‘virtual void Derived::vfunc(int)’ marked ‘override’, but does not override    &#123; &#125; &#125;;struct Derived : public Base&#123;    // 覆盖意味着编译器将检查基类，以查看是否存在具有此确切签名的虚函数。 如果没有，编译器将指示错误。    virtual void vfunc(int) override  // error: ‘virtual void Derived::vfunc(int)’ marked ‘override’, but does not override    &#123; &#125;      virtual void vfunc(float) override  // OK    &#123; &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>当在虚函数声明或定义中使用时，<code>final</code>确保函数为虚并指定其不可被派生类覆盖。否则生成编译时错误。</p><pre class="line-numbers language-c++"><code class="language-c++">struct Base final&#123; &#125;;struct Derived : Base  // error: cannot derive from ‘final’ base ‘Base’ in derived type ‘Derived’&#123; &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当在类定义中使用时，<code>final</code>指定此类不可在另一类的定义中的基类说明符列表中出现（换言之，不能派生于它）。否则生成编译时错误。</p><pre class="line-numbers language-c++"><code class="language-c++">struct Base&#123;    virtual void f() final;  // error: virtual function ‘virtual void Derived::f()’void f();&#125;;struct Derived : public Base&#123;    void f();  // error: virtual function ‘virtual void Derived::f()’ void f();&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Part-13-Lambdas"><a href="#Part-13-Lambdas" class="headerlink" title="Part 13 Lambdas"></a>Part 13 Lambdas</h3><p>C ++引入了lambda，允许定义内联功能，这些功能可用作参数或本地对象。 lambdas更改了C ++标准库的使用方式。</p><p>Lambda是功能的定义,可以在内部语句和表达式中定义。因此，你可以将lambda用作内联函数。 最小lambda函数没有参数，并且简单地完成一些操作。</p><pre class="line-numbers language-c++"><code class="language-c++">[] &#123;     std::cout << "hello lambda" << srd::endl;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>[capture list](params list) mutable<code>opt</code> throwSpec<code>opt</code> -&gt;retType<code>opt</code> {function body}</p><ul><li>capture list：捕获外部变量列表</li><li>params list：形参列表</li><li>mutable指示符：用来说明是否可以修改捕获的变量</li><li>exception：异常说明</li><li>return type：返回类型</li><li>function body：函数体</li></ul><p>捕获以访问lambda内部的非静态外部对象。 可以使用诸如std :: cout之类的静态对象。您可以指定捕获以访问未作为参数传递的外部范围数据。</p><table><thead><tr><th>[ ]</th><th>不捕获任何外部变量</th></tr></thead><tbody><tr><td>[变量名, …]</td><td>默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&amp;说明符）</td></tr><tr><td>[this]</td><td>以值的形式捕获this指针</td></tr><tr><td>[=]</td><td>以值的形式捕获所有外部变量</td></tr><tr><td>[&amp;]</td><td>以引用形式捕获所有外部变量</td></tr><tr><td>[=, &amp;x]</td><td>变量x以引用形式捕获，其余变量以传值形式捕获</td></tr><tr><td>[&amp;, x]</td><td>变量x以值的形式捕获，其余变量以引用形式捕获</td></tr></tbody></table><h3 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h3><p>对象按值传递，但是在lambda定义的函数对象内部，你可以对传递的值进行写访问。</p><h3 id="throwSpec"><a href="#throwSpec" class="headerlink" title="throwSpec"></a>throwSpec</h3><p>提供异常说明</p><h3 id="retType"><a href="#retType" class="headerlink" title="retType"></a>retType</h3><p>在没有对返回类型进行任何特定定义的情况下，将从返回值中推导出来。</p><p><strong>匿名函数对象</strong></p><pre class="line-numbers language-c++"><code class="language-c++">// objects are passed by value, but inside the function object defined by the lambda, // you have write access to the passed value.void func1()&#123;    int id = 0;    auto f = [id] () mutable &#123;        cout << id << " ";        id++;    &#125;;    id = 42;    f();    f();    f();    cout << id << endl;  // print : 0 1 2 42: &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">void func2()&#123;    int id = 0;    auto f = [&id] () &#123;        cout << "id: " << id << endl;        id++;    &#125;;    id = 42;    f();    f();    f();    cout << id << endl;  // print : 42 43 44 45&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">void func3()&#123;    int id = 0;    auto f = [id] () &#123;        cout << "id: " << id << endl;        id++;  // error: increment of read-only variable ‘id’    &#125;;    id = 42;    f();    f();    f();    cout << id << endl;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">void func4()&#123;    int id = 0;    auto f = [id]   () mutable &#123;        cout << "id: " << id << endl;        id++;        static int x = 5;  // 可以声明变量        int y = 6;         // 可以声明返回值        return id;    &#125;;        f();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们编写一个 lambda后， 编译器将该表达时翻译成一个未命名的未命名对象。再 lambda 表达时产生的类中含有一个重载的函数调用运算符。默认情况下 lambda 不能改变它捕获的变量。因此在默认情况下，由 lambda 产生的类当中的函数调用运算符是一个 const 成员函数。如果 lambda 被声明为 mutable， 则调用运算符就不是 const 的了。</p><pre class="line-numbers language-c++"><code class="language-c++">int tobefound = 5;auto lambda1 = [tobefound] (int val) &#123;return val == tobefound;&#125;;class UnNameLocalFunction&#123;    int locaVal;public:       UnNameLocalFunction(int var) : locaVal(var)     &#123; &#125;    bool operator () (int val) const    &#123;        return val = locaVal;    &#125;&#125;;UnNameLocalFunction lambda2(tobefound);bool b1 = lambda1(5);bool b2 = lambda2(5);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Lambda的类型是一个匿名函数对象，对于每个Lambda表达式都是唯一的。 因此，要声明该类型的对象，您需要templates或auto。 如果需要该类型，则可以使用decltype(), 例如，需要将lambda作为散列函数传递，或者将排序或排序规则传递给关联的或无序的容器;</p><pre class="line-numbers language-c++"><code class="language-c++">auto cmp = [] (const Person &p1, const Person &p2)                        &#123;                            return p1.lastname() < p2.lastname()                               || (p1.lastname() == p2.lastname()                                   && p1.firstname() < p2.lastname());                        &#125;;std::set<Person, decltype(cmp)> coll(cmp);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">//set实现template <class Key,          class Compare = less<Key>,          class Alloc = alloc>class set&#123;public:    // typedes:    ...    typedef Compare key_compare;    typedef Compare value_compare;private:    typedef rb_tree<key_type, value_type,                    identity<value_type>,                    key_compare, Alloc> rep_type;    rep_type t; // red-black tree representing setpublic:    ...    set() : t(Compare()) &#123;&#125;    explicit set(const Compare &comp) : t(comp) &#123;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（函数对象是一种非常强大的方法，可自定义标准模板库（STL）算法的行为，并且可以封装代码和数据（与普通函数不同）。 但是由于需要编写整个类，因此函数对象的定义不方便。 而且，它们没有在您试图使用它们的源代码中定义，并且非本地性使它们更难使用。 库已经尝试减轻一些冗长和非局部性的问题，但是由于语法变得复杂并且编译器错误不是很友好，因此没有提供太多帮助。 使用库中的函数对象的效率也较低，因为定义为数据成员的函数对象不是内联的。）</p><p>Lambda表达式解决了这些问题。 以下代码段显示了一个lambda表达式，该表达式在程序中用于从向量整数中删除变量x和y之间的整数。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>#include <vector>#include <algorithm>using namespace std;void func1()&#123;    vector<int> vi &#123;5, 28, 50, 83, 70, 590, 245, 59, 24&#125;;    int x = 30;    int y = 100;    vi.erase(remove_if(vi.begin(),                        vi.end(),                        [x, y](int n) &#123;return x<n && n<y;&#125;                        ),              vi.end()             );    for (auto i : vi)        cout << i << ' ';    cout << endl;&#125;void func2()&#123;    class LambdaFunctor    &#123;    public:        LambdaFunctor(int a, int b) : m_a(a), m_b(b)        &#123; &#125;        bool operator() (int n) const        &#123;            return m_a < n && n < m_b;        &#125;    private:        int m_a;        int m_b;    &#125;;    vector<int> vi &#123;5, 28, 50, 83, 70, 590, 245, 59, 24&#125;;    int x = 30;    int y = 100;    vi.erase(remove_if(vi.begin(),                        vi.end(),                        LambdaFunctor(x, y)),              vi.end()             );    for (auto i : vi)        cout << i << ' ';    cout << endl;&#125;int main()&#123;    func1();    func2();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">//打印结果5 28 590 245 245 28 590 245 24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/01/25/hello-world/"/>
      <url>2020/01/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post.</p><span id="more"></span><p>Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> article </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
